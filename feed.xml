<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Andie&#39;s Blog</title>
  
  
  <link href="/feed.xml" rel="self"/>
  
  <link href="http://blog.andiedie.cn/"/>
  <updated>2019-12-02T18:48:26.450Z</updated>
  <id>http://blog.andiedie.cn/</id>
  
  <author>
    <name>Andie</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>在 MySQL 中存储和查询树形结构</title>
    <link href="http://blog.andiedie.cn/posts/c91d/"/>
    <id>http://blog.andiedie.cn/posts/c91d/</id>
    <published>2019-12-02T16:15:57.000Z</published>
    <updated>2019-12-02T18:48:26.450Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>处理例如目录树、部门层级关系、城乡结构等树形结构是常见的业务场景，本文将讨论几种通过 MySQL 存储和查询此类树形结构的简单方法。</p><a id="more"></a><h1 id="1-场景"><a href="#1-场景" class="headerlink" title="1. 场景"></a>1. 场景</h1><p>现在我们需要实现一个目录树，即一个节点可以拥有若干个子节点。节点的结构设计如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">Id <span class="keyword">int64</span></span><br><span class="line">ParentId <span class="keyword">int64</span></span><br><span class="line">Children []*Node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据存储在 MySQL 上，要求可以递归获取任意一个节点的所有子节点，可以设定下钻的深度。函数接口设计如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getChildren</span><span class="params">(parentId <span class="keyword">int64</span>, depth <span class="keyword">int</span>)</span> []*<span class="title">Node</span></span></span><br></pre></td></tr></table></figure><p>MySQL 表结构设计如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> node</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">id</span>        <span class="built_in">bigint</span> auto_increment primary <span class="keyword">key</span>,</span><br><span class="line">    parent_id <span class="built_in">bigint</span>        <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_parent_id</span><br><span class="line">    <span class="keyword">on</span> node (parent_id);</span><br></pre></td></tr></table></figure><p>随机插入一些测试数据：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertData</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</span><br><span class="line"><span class="keyword">var</span> max sql.NullInt64</span><br><span class="line">_ = mysql.Get(&amp;max, <span class="string">"SELECT MAX(id) FROM node"</span>)</span><br><span class="line">id := rand.Int63n(max.Int64 + <span class="number">1</span>)</span><br><span class="line">_, _ = mysql.Exec(<span class="string">"INSERT INTO node (parent_id) VALUES (?)"</span>, id)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-Naive-方法"><a href="#2-Naive-方法" class="headerlink" title="2. Naive 方法"></a>2. Naive 方法</h1><p>最简单的思路是在程序上做递归，即先获取目标节点的所有子节点，再递归获取子节点的所有子节点，直到下钻深度到达限制。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">naive</span><span class="params">(parentId <span class="keyword">int64</span>, depth <span class="keyword">int</span>)</span> []*<span class="title">Node</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> depth == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">make</span>([]*Node, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">nodes := <span class="built_in">make</span>([]*Node, <span class="number">0</span>)</span><br><span class="line">_ = mysql.Select(&amp;nodes, <span class="string">"SELECT id, parent_id FROM node WHERE parent_id = ?"</span>, parentId)</span><br><span class="line"><span class="keyword">for</span> _, node := <span class="keyword">range</span> nodes &#123;</span><br><span class="line">node.Children = naive(node.Id, depth - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nodes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种思路和实现都非常直观。虽然每次查询数据库都非常快，但是每个节点都需要一次查询。随着节点数量变多，查询数据库的次数也变得非常多，总体执行速度非常慢。使用上述的随机数据，从根节点获取完整树形结构平均需要耗时 8 秒。</p><h1 id="3-递归-CTE"><a href="#3-递归-CTE" class="headerlink" title="3. 递归 CTE"></a>3. 递归 CTE</h1><p>MySQL 8 开始提供了 <a href="https://dev.mysql.com/doc/refman/8.0/en/with.html" target="_blank" rel="noopener">CTE</a>（Common Table Expressions）特性，允许将派生表的逻辑抽取出来单独定义。我们可以使用递归 CTE 来实现上述需求。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cte</span><span class="params">(parentId <span class="keyword">int64</span>, depth <span class="keyword">int</span>)</span> []*<span class="title">Node</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> depth == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">make</span>([]*Node, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> allNodes []*Node</span><br><span class="line">_ = mysql.Select(&amp;allNodes, <span class="string">`</span></span><br><span class="line"><span class="string">WITH RECURSIVE cte (id, parent_id, depth) AS (</span></span><br><span class="line"><span class="string">SELECT id, parent_id, ? AS depth</span></span><br><span class="line"><span class="string">FROM node</span></span><br><span class="line"><span class="string">WHERE parent_id = ?</span></span><br><span class="line"><span class="string">UNION ALL</span></span><br><span class="line"><span class="string">SELECT n.id, n.parent_id, depth - 1</span></span><br><span class="line"><span class="string">FROM node n</span></span><br><span class="line"><span class="string">INNER JOIN cte</span></span><br><span class="line"><span class="string">ON n.parent_id = cte.id AND depth != 1</span></span><br><span class="line"><span class="string">)</span></span><br><span class="line"><span class="string">SELECT id, parent_id FROM cte order by parent_id</span></span><br><span class="line"><span class="string">`</span>, depth, parentId)</span><br><span class="line"></span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int64</span>]*Node)</span><br><span class="line">dummy := &amp;Node&#123;Children: <span class="built_in">make</span>([]*Node, <span class="number">0</span>)&#125;</span><br><span class="line">m[parentId] = dummy</span><br><span class="line"><span class="keyword">for</span> _, node := <span class="keyword">range</span> allNodes &#123;</span><br><span class="line"><span class="keyword">if</span> node.Children == <span class="literal">nil</span> &#123;</span><br><span class="line">node.Children = <span class="built_in">make</span>([]*Node, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">m[node.Id] = node</span><br><span class="line">parent := m[node.ParentId]</span><br><span class="line">parent.Children = <span class="built_in">append</span>(parent.Children, node)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dummy.Children</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述程序分为两个部分，后一部分比较简单，就是将数据库查询结果拼接成树形结构，前一部分的核心是这一段 SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">WITH RECURSIVE cte (id, parent_id, depth) AS (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">id</span>, parent_id, ? <span class="keyword">AS</span> <span class="keyword">depth</span></span><br><span class="line">    <span class="keyword">FROM</span> node</span><br><span class="line">    <span class="keyword">WHERE</span> parent_id = ?</span><br><span class="line">    <span class="keyword">UNION</span> ALL</span><br><span class="line">    <span class="keyword">SELECT</span> n.id, n.parent_id, <span class="keyword">depth</span> - <span class="number">1</span></span><br><span class="line">    <span class="keyword">FROM</span> node n</span><br><span class="line">    <span class="keyword">INNER</span> <span class="keyword">JOIN</span> cte</span><br><span class="line">    <span class="keyword">ON</span> n.parent_id = cte.id <span class="keyword">AND</span> <span class="keyword">depth</span> != <span class="number">1</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, parent_id <span class="keyword">FROM</span> cte <span class="keyword">order</span> <span class="keyword">by</span> parent_id</span><br></pre></td></tr></table></figure><p>我们首先定义了一个递归 CTE，它的执行逻辑是，首先获取 <code>parent_id = ?</code> 的所有节点，然后通过 JOIN 查询这些节点的所有子节点，然后递归查询这些子节点的所有子节点，直到下钻深度满足要求。可以发现逻辑其实和之前的 naive 方法是一样的，但是这里我们借由 MySQL 来实现递归逻辑，从而大大减少了 IO 次数。</p><p>使用上述的随机数据，从根节点获取完整树形结构平均需要耗时 34 毫秒（其中 SQL 的执行时间约 25 毫秒）。</p><h1 id="4-路径查询"><a href="#4-路径查询" class="headerlink" title="4. 路径查询"></a>4. 路径查询</h1><p>递归 CTE 的方法实现简单且效率很高，但是有一个致命的缺点：要求 MySQL 版本在 8 以上。然而很多公司的业务数据库都停留在 5.6 版本，无法支持新特性。不使用递归 CTE，也可以用存储更多信息地方式，通过空间换取时间。</p><p>首先改造 MySQL 的表结构：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> node</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">id</span>        <span class="built_in">bigint</span> auto_increment</span><br><span class="line">        primary <span class="keyword">key</span>,</span><br><span class="line">    parent_id <span class="built_in">bigint</span>        <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    <span class="keyword">path</span>      <span class="built_in">varchar</span>(<span class="number">500</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    <span class="keyword">level</span>     <span class="built_in">int</span>           <span class="keyword">not</span> <span class="literal">null</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_parent_id</span><br><span class="line">    <span class="keyword">on</span> node (parent_id);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_path</span><br><span class="line">    <span class="keyword">on</span> node (<span class="keyword">path</span>(<span class="number">50</span>));</span><br></pre></td></tr></table></figure><p>可以发现这里新增了两个字段：</p><ul><li><code>path</code>：存储从根目录到当前节点的路径信息，例如<code>/0/3/27</code></li><li><code>level</code>：存储当前节点的深度</li></ul><p>另外，这里还对 <code>path</code> 字段添加了一个长度为 50 的前缀索引，用于提高搜索速度。</p><p>代码实现如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">path</span><span class="params">(parentId <span class="keyword">int64</span>, depth <span class="keyword">int</span>)</span> []*<span class="title">Node</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> allNodes []*Node</span><br><span class="line"><span class="keyword">if</span> depth == <span class="number">-1</span> &#123;</span><br><span class="line">depth = <span class="number">99999</span></span><br><span class="line">&#125;</span><br><span class="line">_ = mysql.Select(&amp;allNodes, <span class="string">`</span></span><br><span class="line"><span class="string">SELECT id, parent_id</span></span><br><span class="line"><span class="string">FROM node</span></span><br><span class="line"><span class="string">WHERE path LIKE CONCAT(IFNULL((SELECT path FROM node WHERE id = ?), ''), "/", ?, "%")</span></span><br><span class="line"><span class="string">AND level &lt;= IFNULL((SELECT level FROM node WHERE id = ?), 0) + ?</span></span><br><span class="line"><span class="string">ORDER BY parent_id</span></span><br><span class="line"><span class="string">`</span>, parentId, parentId, parentId, depth)</span><br><span class="line"></span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int64</span>]*Node)</span><br><span class="line">dummy := &amp;Node&#123;Children: <span class="built_in">make</span>([]*Node, <span class="number">0</span>)&#125;</span><br><span class="line">m[parentId] = dummy</span><br><span class="line"><span class="keyword">for</span> _, node := <span class="keyword">range</span> allNodes &#123;</span><br><span class="line"><span class="keyword">if</span> node.Children == <span class="literal">nil</span> &#123;</span><br><span class="line">node.Children = <span class="built_in">make</span>([]*Node, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">m[node.Id] = node</span><br><span class="line">parent := m[node.ParentId]</span><br><span class="line">parent.Children = <span class="built_in">append</span>(parent.Children, node)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dummy.Children</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，代码的后半段是在拼接树形结构，而核心的 SQL 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT id, parent_id</span><br><span class="line">FROM node</span><br><span class="line">WHERE path LIKE CONCAT(IFNULL((SELECT path FROM node WHERE id = ?), &apos;&apos;), &apos;/&apos;, ?, &apos;%&apos;)</span><br><span class="line">AND level &lt;= IFNULL((SELECT level FROM node WHERE id = ?), 0) + ?</span><br><span class="line">ORDER BY parent_id</span><br></pre></td></tr></table></figure><p>逻辑也非常简单：将当前节点的路径取出，拼接后形成目标路径，找到前缀为该路径的所有节点，必然是当前路径的子节点。</p><p>使用上述的随机数据，从根节点获取完整树形结构平均需要耗时 20毫秒（其中 SQL 的执行时间约 8 毫秒）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;处理例如目录树、部门层级关系、城乡结构等树形结构是常见的业务场景，本文将讨论几种通过 MySQL 存储和查询此类树形结构的简单方法。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>树莓派部署记录</title>
    <link href="http://blog.andiedie.cn/posts/754e/"/>
    <id>http://blog.andiedie.cn/posts/754e/</id>
    <published>2019-09-21T05:00:30.000Z</published>
    <updated>2019-11-25T17:50:21.769Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>记录一下新买的树莓派 4 的部署过程，包括系统安装、网络连接、基本配置、Xrdp、Docker、Shadowsocks、Frp、Node.js、RSSHub、Nginx、HTTPS 等内容。本文尽可能提供可以直接执行的 bash 命令，方便后续参考。</p><a id="more"></a><h1 id="1-系统安装"><a href="#1-系统安装" class="headerlink" title="1. 系统安装"></a>1. 系统安装</h1><p>下载地址：<a href="https://www.raspberrypi.org/downloads/raspbian/" target="_blank" rel="noopener">Raspbian</a></p><p>为了方便之后使用 Xrdp 远程连接，下载的版本是带桌面的：</p><p><img src="/assets/1569042878994.png" alt="1569042878994"></p><p>Windows 下写入系统可以使用 <a href="https://sourceforge.net/projects/win32diskimager/" target="_blank" rel="noopener">Win32 Disk Imager</a>，注意设备不要选错了。</p><p><img src="/assets/1569043176140.png" alt="1569043176140"></p><p>写入成功后，在盘符为 <code>boot</code> 的 TF 卡分区根目录下，创建一个名为 <code>ssh</code> 的空文件。新版的 Raspbian 默认不开启 ssh，需要通过这种方式手动开启。</p><p>将 TF 卡插入树莓派，连上网线和电源即可。</p><h1 id="2-网络连接"><a href="#2-网络连接" class="headerlink" title="2. 网络连接"></a>2. 网络连接</h1><p>如果有显示器，直接接入显示器执行 <code>ifconfig</code> 即可获得 ip 地址。没有显示器的情况下，需要先使用网线连接，然后在路由器上查看树莓派有线网卡的 ip 地址。</p><p><img src="/assets/1569043698593.png" alt="1569043698593"></p><p>使用 SSH 登录树莓派，用户 <code>pi</code>，密码为 <code>raspberry</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh pi@ip</span><br></pre></td></tr></table></figure><p>使用 <code>raspi-config</code> 连接 WiFi</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo raspi-config</span><br></pre></td></tr></table></figure><p><img src="/assets/1569043986105.png" alt="1569043986105"></p><p>设置完成后，树莓派会重启。（之后便用不上网线了）</p><h1 id="3-基本配置"><a href="#3-基本配置" class="headerlink" title="3. 基本配置"></a>3. 基本配置</h1><p>别名登录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># vim ~/.ssh/config</span><br><span class="line">Host pi</span><br><span class="line">  HostName pc.andiedie.cn</span><br><span class="line">  Port 22</span><br><span class="line">  User pi</span><br></pre></td></tr></table></figure><p>无密码登录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id pi</span><br></pre></td></tr></table></figure><p>修改密码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo raspi-config</span><br></pre></td></tr></table></figure><p>使用国内镜像加速（<a href="https://mirror.tuna.tsinghua.edu.cn/help/raspbian/" target="_blank" rel="noopener">清华大学开源软件镜像站</a>）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sudo mv /etc/apt/sources.list /etc/apt/sources.list.bak</span><br><span class="line">sudo tee /etc/apt/sources.list &lt;&lt;-<span class="string">'EOF'</span></span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main non-free contrib</span><br><span class="line">deb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main non-free contrib</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">sudo mv /etc/apt/sources.list.d/raspi.list /etc/apt/sources.list.d/raspi.list.bak</span><br><span class="line">sudo tee /etc/apt/sources.list.d/raspi.list &lt;&lt;-<span class="string">'EOF'</span></span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/raspberrypi/ buster main ui</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">sudo apt update</span><br><span class="line"><span class="comment"># 可选，升级所有依赖</span></span><br><span class="line">sudo apt upgrade -y</span><br></pre></td></tr></table></figure><p>安装常用软件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install -y vim unzip</span><br></pre></td></tr></table></figure><h1 id="4-Xrdp-远程桌面"><a href="#4-Xrdp-远程桌面" class="headerlink" title="4. Xrdp 远程桌面"></a>4. Xrdp 远程桌面</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install xrdp -y</span><br></pre></td></tr></table></figure><p>打开 Windows 远程桌面，连接 <code>ip:3389</code>，用户密码留空。</p><p>连接成功后，再输入 pi 的账号和密码即可。</p><h1 id="5-Docker"><a href="#5-Docker" class="headerlink" title="5. Docker"></a>5. Docker</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL get.docker.com | sh -s -- --mirror Aliyun</span><br><span class="line"><span class="comment"># 将当前用户加入 docker 用户组，避免 sudo</span></span><br><span class="line">sudo usermod -aG docker <span class="variable">$USER</span></span><br><span class="line"><span class="comment"># 镜像加速 阿里、七牛云、DaoCloud、Azure</span></span><br><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-<span class="string">'EOF'</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"registry-mirrors"</span>: [</span><br><span class="line">    <span class="string">"https://【注意替换】.mirror.aliyuncs.com"</span>,</span><br><span class="line">    <span class="string">"https://reg-mirror.qiniu.com"</span>,</span><br><span class="line">    <span class="string">"http://【注意替换】.m.daocloud.io"</span>,</span><br><span class="line">    <span class="string">"https://dockerhub.azk8s.cn"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 Docker Compose</span></span><br><span class="line"><span class="comment"># 安装 Python</span></span><br><span class="line">sudo apt install -y python python-pip libffi-dev python-backports.ssl-match-hostname</span><br><span class="line"><span class="comment"># Pip 镜像加速</span></span><br><span class="line">pip config <span class="built_in">set</span> global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">sudo pip config <span class="built_in">set</span> global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">sudo pip install docker-compose</span><br></pre></td></tr></table></figure><h1 id="6-Shadowsock"><a href="#6-Shadowsock" class="headerlink" title="6. Shadowsock"></a>6. Shadowsock</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">sudo apt install -y shadowsocks</span><br><span class="line"><span class="comment"># 配置</span></span><br><span class="line">sudo tee /etc/shadowsocks/config.json &lt;&lt;-<span class="string">'EOF'</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"server"</span>: <span class="string">"【注意替换】"</span>,</span><br><span class="line">    <span class="string">"server_port"</span>: <span class="string">"【注意替换】"</span>,</span><br><span class="line">    <span class="string">"local_address"</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">    <span class="string">"local_port"</span>: <span class="string">"1080"</span>,</span><br><span class="line">    <span class="string">"password"</span>: <span class="string">"【注意替换】"</span>,</span><br><span class="line">    <span class="string">"method"</span>: <span class="string">"【注意替换】"</span></span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"><span class="comment"># 开机启动</span></span><br><span class="line">sudo tee /etc/systemd/system/sslocal.service &lt;&lt;-<span class="string">'EOF'</span></span><br><span class="line">[Unit] </span><br><span class="line">Description = ShadowSocks Client </span><br><span class="line">After = network.target </span><br><span class="line"></span><br><span class="line">[Service] </span><br><span class="line">Type = simple </span><br><span class="line">User = root </span><br><span class="line">ExecStart = sslocal -c /etc/shadowsocks/config.json</span><br><span class="line"></span><br><span class="line">[Install] </span><br><span class="line">WantedBy = multi-user.target</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl start sslocal</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> sslocal</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 polipo 将 socks 协议转为 http</span></span><br><span class="line">sudo apt install -y polipo</span><br><span class="line"><span class="comment"># 配置</span></span><br><span class="line">sudo tee /etc/polipo/config &lt;&lt;-<span class="string">'EOF'</span></span><br><span class="line">logSyslog = <span class="literal">false</span></span><br><span class="line">logFile = /var/<span class="built_in">log</span>/polipo/polipo.log</span><br><span class="line">socksParentProxy = <span class="string">"127.0.0.1:1080"</span></span><br><span class="line">socksProxyType = socks5</span><br><span class="line">proxyAddress = <span class="string">"127.0.0.1"</span></span><br><span class="line">proxyPort = 1088</span><br><span class="line">EOF</span><br><span class="line"><span class="comment"># 开机启动</span></span><br><span class="line">sudo systemctl start polipo</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> polipo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 代理 alias</span></span><br><span class="line">tee -a ~/.bashrc &lt;&lt;-<span class="string">'EOF'</span></span><br><span class="line"><span class="built_in">alias</span> pon=<span class="string">'export use_proxy="on" &amp;&amp; export http_proxy="http://127.0.0.1:1088/" &amp;&amp; export https_proxy=$http_proxy &amp;&amp; export ftp_proxy=$http_proxy &amp;&amp; export dns_proxy=$http_proxy &amp;&amp; export rsync_proxy=$http_proxy &amp;&amp; export no_proxy="localhost,127.0.0.1,localaddress,.localdomain.com"'</span></span><br><span class="line"><span class="built_in">alias</span> poff=<span class="string">'unset use_proxy &amp;&amp; unset http_proxy &amp;&amp; unset https_proxy &amp;&amp; unset ftp_proxy &amp;&amp; unset dns_proxy &amp;&amp; unset rsync_proxy &amp;&amp; unset no_proxy'</span></span><br><span class="line">EOF</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><h1 id="7-Frp"><a href="#7-Frp" class="headerlink" title="7. Frp"></a>7. Frp</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启代理</span></span><br><span class="line">pon</span><br><span class="line"><span class="comment"># 下载</span></span><br><span class="line">wget https://github.com/fatedier/frp/releases/download/v0.29.0/frp_0.29.0_linux_arm.tar.gz</span><br><span class="line"><span class="comment"># 关闭代理</span></span><br><span class="line">poff</span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line">tar -xzf frp_0.29.0_linux_arm.tar.gz</span><br><span class="line"><span class="comment"># 移动到合适的位置</span></span><br><span class="line">sudo mkdir -p /usr/sbin/frp</span><br><span class="line">sudo mv frp_0.29.0_linux_arm/frps /usr/sbin/frp</span><br><span class="line">sudo mkdir -p /etc/frp</span><br><span class="line"><span class="comment"># 清理</span></span><br><span class="line">rm -f frp_0.29.0_linux_arm.tar.gz</span><br><span class="line">rm -rf frp_0.29.0_linux_arm</span><br><span class="line"><span class="comment"># 配置</span></span><br><span class="line">sudo tee /etc/frp/frps.ini &lt;&lt;-<span class="string">'EOF'</span></span><br><span class="line">[common]</span><br><span class="line">bind_port = 7000</span><br><span class="line">dashboard_port = 7500</span><br><span class="line">dashboard_user = 【注意替换】</span><br><span class="line">dashboard_pwd = 【注意替换】</span><br><span class="line">token = 【注意替换】</span><br><span class="line">EOF</span><br><span class="line"><span class="comment"># 开机自启</span></span><br><span class="line">sudo tee /etc/systemd/system/frps.service &lt;&lt;-<span class="string">'EOF'</span></span><br><span class="line">[Unit]</span><br><span class="line">Description=FRP Server Daemon</span><br><span class="line">After=network.target</span><br><span class="line">Wants=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">ExecStart=/usr/sbin/frp/frps -c /etc/frp/frps.ini</span><br><span class="line">Restart=always</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl start frps</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> frps</span><br></pre></td></tr></table></figure><h1 id="8-Node-js"><a href="#8-Node-js" class="headerlink" title="8. Node.js"></a>8. Node.js</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install -y nodejs npm</span><br><span class="line">sudo npm i -g npm --registry=https://registry.npm.taobao.org</span><br><span class="line">sudo npm i -g nrm --registry=https://registry.npm.taobao.org</span><br><span class="line">nrm use cnpm</span><br><span class="line">sudo npm i -g yarn n</span><br><span class="line">pon</span><br><span class="line">sudo n lts</span><br><span class="line">poff</span><br></pre></td></tr></table></figure><h1 id="9-RSSHub"><a href="#9-RSSHub" class="headerlink" title="9. RSSHub"></a>9. RSSHub</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/pi/Desktop</span><br><span class="line">pon</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/DIYgod/RSSHub.git</span><br><span class="line">poff</span><br><span class="line"><span class="built_in">cd</span> RSSHub/</span><br><span class="line">yarn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开机启动</span></span><br><span class="line">sudo tee /etc/systemd/system/rsshub.service &lt;&lt;-<span class="string">'EOF'</span></span><br><span class="line">[Unit] </span><br><span class="line">Description = RSSHub</span><br><span class="line">After = network.target </span><br><span class="line"></span><br><span class="line">[Service] </span><br><span class="line">Type = simple </span><br><span class="line">ExecStart = /bin/bash -c <span class="string">'PROXY_PROTOCOL=socks PROXY_HOST=127.0.0.1 PROXY_PORT=1080 PROXY_URL_REGEX="instagram|twitter" TWITTER_CONSUMER_KEY=【注意替换】 TWITTER_CONSUMER_SECRET=【注意替换】 GITHUB_ACCESS_TOKEN=【注意替换】 yarn --cwd /home/pi/Desktop/RSSHub start'</span></span><br><span class="line"></span><br><span class="line">[Install] </span><br><span class="line">WantedBy = multi-user.target</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">sudo systemctl start rsshub</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> rsshub</span><br></pre></td></tr></table></figure><h1 id="10-Nginx"><a href="#10-Nginx" class="headerlink" title="10. Nginx"></a>10. Nginx</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 Certbot</span></span><br><span class="line">sudo apt install -y certbot</span><br><span class="line"><span class="comment"># 安装 nginx</span></span><br><span class="line">sudo apt install -y nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开 https://nginxconfig.io/?0.domain=rss.andiedie.cn&amp;0.document_root=&amp;0.redirect=false&amp;0.email=zchangan@163.com&amp;0.php=false&amp;0.proxy&amp;0.proxy_pass=http:%2F%2F127.0.0.1:1200&amp;0.root=false</span></span><br><span class="line"><span class="comment"># 下载 zip 文件，放到 /etc/nginx 目录下</span></span><br><span class="line"><span class="built_in">cd</span> /etc/nginx</span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line">sudo unzip -o nginxconfig.io-rss.andiedie.cn.zip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成 Diffie-Hellman 参数</span></span><br><span class="line">sudo openssl dhparam -out /etc/nginx/dhparam.pem 2048</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获得泛域名证书（renew 也是这样）</span></span><br><span class="line">sudo certbot certonly --preferred-challenges dns --manual -d *.andiedie.cn --email zchangan@163.com --agree-tos --force-renewal --server https://acme-v02.api.letsencrypt.org/directory</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据要求给 DNS 添加 TXT 记录</span></span><br><span class="line"><span class="comment"># 还需要添加 CAA 记录，推荐 cloudflare</span></span><br><span class="line"><span class="comment"># CAA andiedie.cn 0 issue ";"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加 SSL 证书通用配置</span></span><br><span class="line">sudo tee /etc/nginx/ssl.conf &lt;&lt;-<span class="string">'EOF'</span></span><br><span class="line">ssl_certificate /etc/letsencrypt/live/andiedie.cn/fullchain.pem;</span><br><span class="line">ssl_certificate_key /etc/letsencrypt/live/andiedie.cn/privkey.pem;</span><br><span class="line">ssl_trusted_certificate /etc/letsencrypt/live/andiedie.cn/chain.pem;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 SSL 三连 改为</span></span><br><span class="line"><span class="comment"># include ssl.conf;</span></span><br><span class="line">sudo vim /etc/nginx/sites-available/frp.andiedie.cn.conf</span><br><span class="line">sudo vim /etc/nginx/sites-available/frp.andiedie.cn.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">sudo nginx -t &amp;&amp; sudo systemctl reload nginx</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> nginx</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一下新买的树莓派 4 的部署过程，包括系统安装、网络连接、基本配置、Xrdp、Docker、Shadowsocks、Frp、Node.js、RSSHub、Nginx、HTTPS 等内容。本文尽可能提供可以直接执行的 bash 命令，方便后续参考。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>不靠谱租房指南</title>
    <link href="http://blog.andiedie.cn/posts/d968/"/>
    <id>http://blog.andiedie.cn/posts/d968/</id>
    <published>2019-05-09T09:20:19.000Z</published>
    <updated>2019-05-10T13:08:47.189Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近我和女友都准备毕业工作，于是分别在广州和深圳都租了房子。这篇博客记录我在租房前后积累的一些租房、看房、签合同相关的经验，以备不时之需。</p><a id="more"></a><h1 id="1-获取房源信息"><a href="#1-获取房源信息" class="headerlink" title="1. 获取房源信息"></a>1. 获取房源信息</h1><p>租房的第一步就是获取房源，现在途径有很多：</p><ul><li>链家、自如、贝壳、安居客等在线平台</li><li>魔方公寓、泊寓等精装修房源</li><li>线下中介</li><li>58、赶集之类的信息发布网站</li><li>豆瓣小组、知乎等小众平台</li><li>扫街</li></ul><p>接下来从获取难度、可靠程度、价格等方面，简单介绍一下每一种房源。满分五颗星，星星越多，获取难度越大，可靠程度越高，价格越低。</p><h2 id="1-1-租房信息来源比较"><a href="#1-1-租房信息来源比较" class="headerlink" title="1.1. 租房信息来源比较"></a>1.1. 租房信息来源比较</h2><h3 id="1-1-1-线上租房平台"><a href="#1-1-1-线上租房平台" class="headerlink" title="1.1.1. 线上租房平台"></a>1.1.1. 线上租房平台</h3><p>难度：★☆☆☆☆</p><p>可靠：★★★☆☆</p><p>价格：★★★☆☆</p><p>一般人最容易接触到的就是各类线上的租房平台，例如链家、贝壳、安居客、自如等。从这类平台上获取信息非常容易，但是一些不靠谱的平台上各类租房信息也是鱼龙混杂。比如安居客上，会出现非常多低价房源，价格低到难以置信，但是房间图片却非常精美。一般这种房源是为了吸引租客看房，如果对方比较善良，那顶多就是以“房间刚刚租了”之类的理由带租客去看一些贵的房源，对方狡诈一点的话还会通过收取看房费骗租客的钱。</p><p>我自用了很多平台，最后还是比较推荐贝壳（贝壳的财务看到了请给我打钱谢谢）。主要是因为贝壳爬了很多别的平台的信息（安居客前段时间就因为这个告了贝壳），可以一次搞定多个平台的搜索；贝壳上的低价不靠谱房源在我使用的过程中也出现得比较少；最推荐的理由是贝壳可以筛选公司附近几公里内的房源（无法想象为什么这么基础的功能别家居然没有）。</p><h3 id="1-1-2-精装修公寓"><a href="#1-1-2-精装修公寓" class="headerlink" title="1.1.2. 精装修公寓"></a>1.1.2. 精装修公寓</h3><p>难度：★☆☆☆☆</p><p>可靠：★★★★★</p><p>价格：★☆☆☆☆</p><p>这类诸如魔方、泊寓之类的精装修公寓，也可以在贝壳、安居客之类的平台上看到，优点是非常可靠，家电齐全、安保完善、周边购物或交通比较便利，且一般都有桌游室、台球桌、健身房之类的公共空间。缺点同样非常明显，就是贵，不仅房租贵、管理费贵，一般用的是商用水电，所以每月水电费也贵。</p><h3 id="1-1-3-线下中介"><a href="#1-1-3-线下中介" class="headerlink" title="1.1.3. 线下中介"></a>1.1.3. 线下中介</h3><p>难度：★★☆☆☆</p><p>可靠：★★★☆☆</p><p>价格：★★★☆☆</p><p>最传统的就是找一些线下卖二手房和租房的中介，就是那种店面玻璃上贴满了房源信息的店。其实绝大多数个人房源，特别是房间多的套房，房东都没闲功夫自己找人出租，这类中介就负责从房东手里接管房子的出租权，然后租给租客。</p><p>获取难度略高，因为需要线下跑店面，但是综合来说也相当省时省力，毕竟你只需要告诉中介你的目标房型、价格、位置等信息，他会帮你筛选。缺点也有，一个是需要中介费，一般是一个月或半月的房租作为中介费；另外就是中介手上的房子可能还是套房居多，个人租单间的话不太合适。</p><h3 id="1-1-4-信息发布网站"><a href="#1-1-4-信息发布网站" class="headerlink" title="1.1.4. 信息发布网站"></a>1.1.4. 信息发布网站</h3><p>难度：★★☆☆☆</p><p>可靠：★☆☆☆☆</p><p>价格：★★★☆☆</p><p>类似 58 同城、赶集网之类的信息发布网站上一般也会有租房信息，不过分为两类：一类是房东直租，这类房子免中介费、租金不高，就是比较少遇到；另一类就是中介发布的信息，线下中介的主要宣传方式就是这类信息发布网站。不过也不要因为对方是中介就有什么避讳，勤在 58 上发信息、甚至买精选的中介，一般都是用心做的，相对还是比较靠谱的。</p><h3 id="1-1-5-小众平台"><a href="#1-1-5-小众平台" class="headerlink" title="1.1.5. 小众平台"></a>1.1.5. 小众平台</h3><p>难度：★★★★☆</p><p>可靠：★★★★☆</p><p>价格：★★★☆☆</p><p>豆瓣小组、知乎甚至某些神秘的 QQ、微信群里面也可以淘到不少优质的租房信息。这些租房信息真实度高，价格也合理，主要的缺点就是这类小众平台缺乏针对租房的筛选功能，因此获取对口的租房信息其实非常耗费时间精力。</p><h3 id="1-1-6-扫街"><a href="#1-1-6-扫街" class="headerlink" title="1.1.6. 扫街"></a>1.1.6. 扫街</h3><p>难度：★★★★★</p><p>可靠：★★★★☆</p><p>价格：★★★★☆</p><p>最硬核的租房方式就是扫街，到租房地附近的小区大门、电线杆之类的地方看房东贴出来的租房广告，或者问门卫大叔、居委会大妈之类的角色，他们一般都知道哪家要租房。直接联系到房东，价格便宜、信息真实，就是要找到这样的房子是要靠步数和运气的。</p><h2 id="1-2-综合推荐"><a href="#1-2-综合推荐" class="headerlink" title="1.2. 综合推荐"></a>1.2. 综合推荐</h2><p>最后还是推荐直接在链家、贝壳之类的地方直接看房源，说实话省时省心且相对靠谱。不过在平台上挑房子也是有要注意的地方，没必要拘泥于同一个小区内的不同装修的房子，或者是同一个中介手上区别不大的房子，要多看不同的小区、多看不同中介手上的房子，因为事后看房的事后，中介会领你看同一个小区和附近的所有房子。线上只需要关注位置、交通等关键部分，细节交给线下看房。</p><h1 id="2-看房"><a href="#2-看房" class="headerlink" title="2. 看房"></a>2. 看房</h1><h2 id="2-1-约看房"><a href="#2-1-约看房" class="headerlink" title="2.1. 约看房"></a>2.1. 约看房</h2><p>约房东或者中介看房，如果是女生的话一定要找人同行，独自看房非常危险。一天可以约三个左右的中介，早中晚各一个。看房速度其实很快，一个区域内的房间一个小时内就能全部看完。用更少的时间，看更多的小区。</p><h2 id="2-2-看房列表"><a href="#2-2-看房列表" class="headerlink" title="2.2. 看房列表"></a>2.2. 看房列表</h2><p>跟中介进了房间，就要开始注意以下内容：</p><ul><li>安全：如果是女生独自看房，注意一定不要关门，方便随时逃跑；</li><li>隔音：用手敲一敲墙壁是不是隔音好的承重墙、门窗缝隙会不会过大。有条件的话还可以打开水龙头、花洒、冲厕所、抽油烟机等方法听一听声音是否过大；</li><li>晾晒：房间是否有足够的晾晒空间比如阳台，是否有楼顶等公共晾晒空间；</li><li>网络：打开手机，看网络信号，有条件的话三个运营商的都看一下；询问是否有自带宽带、资费如何、是否可以自拉网线等；</li><li>损坏：门窗是否能够正常开馆、房间内的墙面插座是否有效、厕所冲水是否有效等；</li><li>电器：空调、冰箱、洗衣机、热水器等电器的新旧情况，另外一定要注意有些电器是否是需要“扫码付费使用”；</li><li>漏水：洗手池、浴室、测试、阳台是否能正常漏水，房间内的管道、阳台外的管道是否会渗水；</li><li>水电：商用水电还是民用水电；</li><li>周边：是否有 24 小时便利店、菜市场、超市；</li><li>管理：管理费多少钱，是否包维修；</li><li>宠物：是否可以养宠物</li></ul><h1 id="3-签合同"><a href="#3-签合同" class="headerlink" title="3. 签合同"></a>3. 签合同</h1><h2 id="3-1-签合同之前"><a href="#3-1-签合同之前" class="headerlink" title="3.1 签合同之前"></a>3.1 签合同之前</h2><p>签合同之前有很多需要注意的地方：</p><ul><li>如何支付房租、如果延迟交房租如何处理</li><li>水电、网络、天然气费用如何缴纳</li><li>提早搬离如何处理</li><li>房屋改造的限制和手续，比如更换灯具、刷墙、粘贴、打孔等</li><li>如何续约</li><li>押金多少，扣押金的条件</li><li>切勿随意缴纳定金</li></ul><h2 id="3-2-合同本身"><a href="#3-2-合同本身" class="headerlink" title="3.2. 合同本身"></a>3.2. 合同本身</h2><p>仔细阅读合同条款，特别注意：</p><ul><li>租房人和承租人信息是否正确</li><li>租期、房间号、房租、押金是否正确</li><li>条款是否与口头不一致</li></ul><p>另外有一些关于租房合同的常识：</p><ul><li>《 合同法 》 第 215 条规定：租赁期限六个月以上的，应当采用书面形式。当事人未采用书面形式的，视为不定期租赁。（不定期租赁时，双方都可以随时单方面接触租赁关系，如果是出租人解除，则需要给与承租人合理的搬迁期限）</li><li>《 房地产管理法 》 第 54 条规定：房屋租赁，出租人和承租人应当签订书面租赁合同，并向房产管理部分登记备案。但是登记备案不是租赁合同生效的必要条件，因此也可以不登记。</li><li>《 商品房屋租赁管理办法 》 第八条：出租住房的，应当以原设计的房间为最小出租单位，人均租住建筑面积不得低于当地人民政府规定的最低标准。厨房、卫生间、阳台和地下储藏室不得出租供人员居住。因此注意，将房间分割后进行出租的行为，是违法的。</li></ul><h2 id="3-3-签完合同"><a href="#3-3-签完合同" class="headerlink" title="3.3. 签完合同"></a>3.3. 签完合同</h2><p>签完合同时需要注意：</p><ul><li>保留合同、房东身份证明（身份证复印件）、房屋所有权证书（房产证复印件）、租房授权委托书（如果对方是中介则需要）</li><li>拍照记录房间内的所有细节，包括现有的破损情况、家具和家电的新旧情况等</li><li>记录当前水电表读数（方便日后核对）</li><li>保留押金、租金、中介费的收据</li><li>保留家具清单</li><li>保留房东的通讯地址</li></ul><p>以上就是我个人的一些租房经验，希望有所帮助。祝大家都能租到满意的房子。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近我和女友都准备毕业工作，于是分别在广州和深圳都租了房子。这篇博客记录我在租房前后积累的一些租房、看房、签合同相关的经验，以备不时之需。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>TVPause : 接打电话时自动暂停电视</title>
    <link href="http://blog.andiedie.cn/posts/cb98/"/>
    <id>http://blog.andiedie.cn/posts/cb98/</id>
    <published>2019-02-11T14:42:19.000Z</published>
    <updated>2019-05-10T13:08:07.543Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近家里有个小的需求，就是希望在接打电话的时候能够自动暂停电视节目。于是我就写了一个简单的工具，这篇博客主要记录实现的过程、遇到的问题以及一些小的心得。开源地址：<a href="https://github.com/Andiedie/TVPause" target="_blank" rel="noopener">TVPause</a></p><a id="more"></a><p><img src="/assets/image-20190211184923522.gif" alt="image-20190211184923522"></p><h1 id="1-需求"><a href="#1-需求" class="headerlink" title="1. 需求"></a>1. 需求</h1><p>也许有人会奇怪为什么会有“接打电话的时候自动暂停电视节目”这种伪需求，直接按个遥控器上静音或者暂停按钮不就行了吗？事情并没有那么简单。</p><ul><li>首先，家里有一个习惯是，吃饭的时候看电视，如果吃饭的时候来电话，得先放下碗筷，静音/暂停电视，然后接听电话，步骤很多</li><li>其次，爸爸做小本生意，晚上经常会有订货的电话，因此这个需求出现的频次很高</li><li>最后，家里用的是小米电视，小米电视遥控器，<strong>没有静音按钮</strong>！🤨</li></ul><p>因此我决定着手解决这个问题，理想的状态时，一旦来电，如果正在播放点播节目，就直接暂停；如果正在收看电视直播，就静音。</p><p>不过后来发现，想要获取小米电视正在播放点播节目还是电视直播并不容易，于是就选择了一种“又不是不能用”的实现方法：一旦来电，模拟按下确认按钮（如果是点播节目会暂停，直播则无效果），并静音；电话结束后，再次模拟按下确认按钮（点播节目会继续，直播则无效果），恢复音量。</p><p>这样的好处是，实现简单。坏处是，模拟点击确认按钮这个过程不够可靠，会误触一些其他按钮。例如此时电视其实并没有在播放节目，而是在主界面待机，此时来电点击确认按钮的话，就会选中光标内容。</p><p>无伤大雅，只要使用上略加注意就行了，开发效率万岁。🎉</p><p><strong>最终流程：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">接打电话 → 保存当前音量值 → 模拟点击确认 → 调整音量为 0</span><br><span class="line"></span><br><span class="line">电话结束 → 读取备份音量值 → 模拟点击确认 → 恢复备份音量</span><br></pre></td></tr></table></figure><h1 id="2-小米电视协议分析"><a href="#2-小米电视协议分析" class="headerlink" title="2. 小米电视协议分析"></a>2. 小米电视协议分析</h1><p>家里的手机都没有红外接口，且红外对物理要求太高，所以我直接放弃了红外这条路。下一条路就是分析小米电视的 APP “小米投屏神器” 的协议。</p><h2 id="2-1-初战-HTTP-协议"><a href="#2-1-初战-HTTP-协议" class="headerlink" title="2.1. 初战 HTTP 协议"></a>2.1. 初战 HTTP 协议</h2><p>最容易想到和分析的就是 HTTP 协议，按照 <a href="/posts/cc60/">移动设备抓包</a> 这篇博客中的介绍，使用 Charles 抓包，结果如下：</p><h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><p><img src="/assets/image-20190211124903539.png" alt="image-20190211124903539"></p><p>打开 APP 第一步必然是先找到小米电视的服务地址，这里发现了一条功能类似的 API，提供了小米电视非常详细的信息。但是这个 API 虽然使用的是 HTTPS，但是证书确实私自签发的，直接请求会报错：</p><p><img src="/assets/image-20190211125140930.png" alt="image-20190211125140930"></p><p>且里面有一些参数例如，<code>deviceid</code> 和 <code>key</code> 还暂时不知道来源。</p><p>另外最重要的是，这个 API 是向公网请求的设备信息，而服务发现应该是在局域网就能完成的事情，所以暂时放弃该 API。</p><h3 id="获取音量"><a href="#获取音量" class="headerlink" title="获取音量"></a>获取音量</h3><p>在进入手机遥控器的时候，手机会发起一个获取音量的请求：</p><p><img src="/assets/image-20190211125439899.png" alt="image-20190211125439899"></p><p>这个 API 就非常友好：</p><ul><li>向内网的小米电视发送请求</li><li>HTTP 协议</li><li>没有乱七八糟的参数</li></ul><p>可以直接拿来用</p><h3 id="设置音量"><a href="#设置音量" class="headerlink" title="设置音量"></a>设置音量</h3><p>在 APP 上调整音量有两个方式，一个是通过手机音量键步进调整，一个是使用 UI 上的拖动条直接一步到位。</p><p>步进调整的请求使用 Charles 无法获取，下面是拖动调整的 API：</p><p><img src="/assets/image-20190211125754298.png" alt="image-20190211125754298"></p><p>这里的 API 和上面的获取音量的非常相似，有如下参数</p><ul><li><code>action</code>：<code>setVolum</code> 表示设置音量</li><li><code>volum</code>：目标音量</li><li><code>ts</code>：时间戳</li><li><code>sign</code>：签名</li></ul><p>问题就出在这个签名上，签名一般是将参数以某种顺序拼接后，附带盐值，然后使用 Hash 算法计算。这里不知道拼接顺序，也不知道是否有盐值，更不知道算法是什么，所以使用这个 API 非常困难。</p><h3 id="失败"><a href="#失败" class="headerlink" title="失败"></a>失败</h3><p>接着发现包括步进调整音量、点击确认、上下左右等所有 APP 上的点按按键都无法使用 Charles 获取请求，很明显这里使用的不是 HTTP 请求，再加上之前服务发现和设置音量的 API 不可用，所以第一次挑战 HTTP API 失败。</p><h2 id="2-2-TCP-UDP-协议"><a href="#2-2-TCP-UDP-协议" class="headerlink" title="2.2. TCP / UDP 协议"></a>2.2. TCP / UDP 协议</h2><p>既然 Charles 不行，那就上 Wireshark。按照 <a href="/posts/cc60/">移动设备抓包</a> 这篇博客中介绍的，使用 Wireshark 监听 iPhone 上的数据包。</p><h3 id="点击按钮"><a href="#点击按钮" class="headerlink" title="点击按钮"></a>点击按钮</h3><p>开启 Wireshark，点击“确认”按钮后，拦截到数据包，适当过滤后：</p><p><img src="/assets/image-20190211131501834.png" alt="image-20190211131501834"></p><p>两个包的内容分别为</p><p><img src="/assets/image-20190211131253854.png" alt="image-20190211131253854"></p><p><img src="/assets/image-20190211131301793.png" alt="image-20190211131301793"></p><p>其中，蓝色的部分就是 TCP 的数据字段。经过多次拦截和分析后，总结出的协议格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0000    04 00 41 01 00 00 00 45 00 3a 01 00 00 00 00 02</span><br><span class="line">0010    00 00 00 01 03 00 00 00 42 04 00 00 00 1c 05 00</span><br><span class="line">0020    00 00 00 06 00 00 00 08 07 00 00 00 00 00 00 00</span><br><span class="line">0030    00 08 00 00 00 00 00 00 00 00 0a ff ff ff ff 0b</span><br><span class="line">0040    00 00 03 01</span><br></pre></td></tr></table></figure><ul><li>0004 ~ 0007 是序号，每次发送 +1</li><li>0010 ~ 0013 每次按键时会发送两次几乎一模一样的 TCP 包，第一次该字段为 0， 第二次为 1。推测应该是按键状态，0 表示按下，1 表示松开。</li><li>0018 ~ 001f 是按键码，详见下表</li><li>其他位保持变即可</li></ul><p>按键码表：</p><table><thead><tr><th>按键功能</th><th>按键码</th></tr></thead><tbody><tr><td>电源</td><td>0x1a04000000740500</td></tr><tr><td>上</td><td>0x1304000000670500</td></tr><tr><td>下</td><td>0x14040000006c0500</td></tr><tr><td>左</td><td>0x1504000000690500</td></tr><tr><td>右</td><td>0x16040000006a0500</td></tr><tr><td>确认</td><td>0x42040000001c0500</td></tr><tr><td>主页</td><td>0x0304000000660500</td></tr><tr><td>返回</td><td>0x04040000009e0500</td></tr><tr><td>菜单</td><td>0x05040000008b0500</td></tr><tr><td>音量增</td><td>0x1804000000730500</td></tr><tr><td>音量减</td><td>0x1904000000720500</td></tr></tbody></table><h3 id="服务发现-1"><a href="#服务发现-1" class="headerlink" title="服务发现"></a>服务发现</h3><p>在使用 Wireshark 监听时发现，除了上述的 TCP 包用于发送指令，APP 还会在刚启动时使用 mDNS 协议寻找服务：</p><p><img src="/assets/image-20190211141728625.png" alt="image-20190211141728625"></p><p>如上图，前 4 个包是 APP 刚启动时，向所有网段广播寻找 <code>_rc._tcp</code> 类型的服务。之后小米电视收到广播，回复了服务的端口和地址，并附带了小米电视的详细信息。</p><p>在命令行可以使用下列命令模拟：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 搜索服务</span></span><br><span class="line">dns-sd -B _rc._tcp <span class="built_in">local</span></span><br><span class="line"><span class="comment"># 获取服务相信信息</span></span><br><span class="line">dns-sd -L 客厅的小米盒子 _rc._tcp.</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20190211142039290.png" alt="image-20190211142039290"></p><h2 id="2-3-再战-HTTP-协议"><a href="#2-3-再战-HTTP-协议" class="headerlink" title="2.3. 再战 HTTP 协议"></a>2.3. 再战 HTTP 协议</h2><p>其实到之前的步骤已经可以实现整个应用了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">接打电话 → 通过 mDNS 协议搜索小米电视 → 通过 HTTP 协议获取当前音量 → 保存当前音量 → 通过 TCP 协议按下确认键并调节音量至0</span><br><span class="line"></span><br><span class="line">电话结束 → 通过 mDNS 协议搜索小米电视 → 通过 HTTP 协议获取当前音量 → 读取存档音量 → 通过 TCP 协议按下确认键并恢复音量</span><br></pre></td></tr></table></figure><p>实际上我也实现另一个这样的版本，但是遇到了几个问题：</p><ul><li>在使用 TCP 连接上小米电视后，第一次连接总是会被服务端关闭 Socket。原因不明，应该不是我的实现问题，因为 APP 也会出现这个问题。</li><li>如果当前音量是 50，那么调整音量为 0 需要至少 50 个 TCP 包。当然理论上是 100 个，包括 50 次音量下键每次两个包，但是测试发现只发送第一个包也没什么问题，因此是 50 个。这样速度慢，并且非常不稳定。</li></ul><p>上述两个问题出现一个还好解决，但是总是一起出现，比如调节音量的包发了几个，Socket 被关了，处理起来非常麻烦。</p><p>所以我放弃了这个方案，决定再战一次 HTTP 协议，毕竟有个 <code>setVolum</code> 的 API 实在非常诱人。</p><h1 id="3-反编译"><a href="#3-反编译" class="headerlink" title="3. 反编译"></a>3. 反编译</h1><p>无法使用 <code>setVolum</code> 的原因是不知道如何计算 <code>sign</code>，既然如此，就直接反编译 APP 看看，这个签名究竟是怎么算出来的。关于反编译的简易教程可以查看<a href="/posts/552a/">这篇博客</a>。</p><h2 id="3-1-查看源码"><a href="#3-1-查看源码" class="headerlink" title="3.1. 查看源码"></a>3.1. 查看源码</h2><p>让我们列一个任务表，更加清晰地追踪源码：</p><table><thead><tr><th>任务</th><th>完成</th></tr></thead><tbody><tr><td>计算签名的输入</td><td></td></tr><tr><td>计算签名的算法</td></tr></tbody></table><h3 id="分析设置音量的函数"><a href="#分析设置音量的函数" class="headerlink" title="分析设置音量的函数"></a>分析设置音量的函数</h3><p>使用 jd-gui 查看投屏神器的源码，找到设置音量的对应函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.xiaomi.mitv.phone.tvassistant.b.a.a(int) : void</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">(<span class="keyword">int</span> paramInt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    String str1 = String.valueOf(System.currentTimeMillis());</span><br><span class="line">    String str2 = a(String.valueOf(paramInt), <span class="keyword">this</span>.b, str1);</span><br><span class="line">    <span class="keyword">new</span> c(<span class="keyword">this</span>.d, String.format(<span class="string">"http://%s:6095/general?action=setVolum&amp;volum=%d&amp;ts=%s&amp;sign=%s"</span>, <span class="keyword">new</span> Object[] &#123; <span class="keyword">this</span>.a, Integer.valueOf(paramInt), str1, str2 &#125;), <span class="keyword">new</span> c.a()</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">(<span class="keyword">int</span> paramAnonymousInt, String paramAnonymousString)</span> </span>&#123;&#125;</span><br><span class="line">          &#125;).d();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，第 6 行发出了请求，根据 <code>String.format</code>可以得知一些变量对应的信息：</p><ul><li><code>paramInt</code>： 目标音量值</li><li><code>str1</code>：当前时间</li><li><code>str2</code>：签名</li></ul><p>显然，如何计算 <code>str2</code> 是最令人感兴趣的部分。</p><p>来到第 5 行，发现 <code>str2</code> 使用函数 <code>a</code> 计算，函数 <code>a</code> 就是计算签名的函数。</p><p>函数 <code>a</code> 的参数分别为：</p><ul><li><code>String.valueOf(paramInt)</code>：目标音量</li><li><code>this.b</code>：暂时不明</li><li><code>str1</code>：当前时间</li></ul><table><thead><tr><th>任务</th><th>完成</th></tr></thead><tbody><tr><td>计算签名的输入</td><td>❓</td></tr><tr><td>计算签名的算法</td><td>❓</td></tr><tr><td><code>this.b</code> 是什么</td><td>❓</td></tr></tbody></table><h3 id="分析签名的输入"><a href="#分析签名的输入" class="headerlink" title="分析签名的输入"></a>分析签名的输入</h3><p>查看函数 <code>a</code> 的逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.xiaomi.mitv.phone.tvassistant.b.a.a(String, String, String) : String</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">a</span><span class="params">(String paramString1, String paramString2, String paramString3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> g.a(<span class="string">"mitvsignsalt"</span> + paramString1 + paramString2 + paramString3.substring(paramString3.length() - <span class="number">5</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，这就是计算 <code>sign</code> 的函数，计算逻辑如下：</p><ul><li>将盐值 <code>mitvsignsalt</code>、目标音量 <code>paramString1</code>、<code>paramString2</code>（即<code>this.b</code>）和当前时间 <code>paramString3</code> 拼接在一起</li><li>调用函数 <code>g.a</code> 计算</li></ul><p>至此，我们搞懂了计算签名的输入，就是上述的字符串拼接。</p><table><thead><tr><th>任务</th><th>完成</th></tr></thead><tbody><tr><td>计算签名的输入</td><td>✅</td></tr><tr><td>计算签名的算法</td><td>❓</td></tr><tr><td><code>this.b</code> 是什么</td><td>❓</td></tr></tbody></table><h3 id="分析签名的算法"><a href="#分析签名的算法" class="headerlink" title="分析签名的算法"></a>分析签名的算法</h3><p>让我们看看 <code>g.a</code> 干了什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.xiaomi.mitv.socialtv.common.e.g.a(String) : String</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">a</span><span class="params">(String paramString)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (paramString == <span class="keyword">null</span>) &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (paramString = <span class="string">""</span>;; paramString = a(paramString.getBytes())) &#123;</span><br><span class="line">        <span class="keyword">return</span> paramString;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>g.a</code> 调用了一个重载的函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.xiaomi.mitv.socialtv.common.e.g.a(byte[]) : String</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">a</span><span class="params">(<span class="keyword">byte</span>[] paramArrayOfByte)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (paramArrayOfByte == <span class="keyword">null</span>) &#123;</span><br><span class="line">        paramArrayOfByte = <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> paramArrayOfByte;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            MessageDigest localMessageDigest = MessageDigest.getInstance(<span class="string">"MD5"</span>);</span><br><span class="line">            localMessageDigest.reset();</span><br><span class="line">            localMessageDigest.update(paramArrayOfByte);</span><br><span class="line">            paramArrayOfByte = e.a(localMessageDigest.digest());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception paramArrayOfByte)</span><br><span class="line">        &#123;</span><br><span class="line">            paramArrayOfByte = <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显了，签名的算法是 MD5</p><table><thead><tr><th>任务</th><th>完成</th></tr></thead><tbody><tr><td>计算签名的输入</td><td>✅</td></tr><tr><td>计算签名的算法</td><td>✅</td></tr><tr><td><code>this.b</code> 是什么</td><td>❓</td></tr></tbody></table><h3 id="this-b-是什么"><a href="#this-b-是什么" class="headerlink" title="this.b 是什么"></a><code>this.b</code> 是什么</h3><p>只要搞清楚 <code>this.b</code> 是什么，我们就可以计算签名了。而且根据经验，它很可能是一个 <code>key</code>。由服务端（小米电视）和客户端（手机 APP）共同拥有。</p><p>然而很遗憾，以我的功力，没能够在代码里面找到 <code>this.b</code> 的来源，所以我换了一个新方法。</p><h2 id="3-2-重编译-APP"><a href="#3-2-重编译-APP" class="headerlink" title="3.2. 重编译 APP"></a>3.2. 重编译 APP</h2><p>既然没办法直接把 <code>this.b</code> 是什么看出来，我就想着干脆用日志把它的值输出出来，看看有什么猫腻。</p><p>这就涉及到反编译 APP，修改源码，重新打包和签名，具体过程可以查看<a href="/posts/552a/">这篇博客</a>。</p><p>唯一修改的文件 <code>smali/com/xiaomi/mitv/phone/tvassistant/b/a.smali</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">.method public a(I)V</span><br><span class="line">    <span class="comment"># 额外定义 4 个寄存器用于存储 TAG</span></span><br><span class="line">    .locals 12</span><br><span class="line"></span><br><span class="line">    .prologue</span><br><span class="line">    .line 55</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置初始化TAG</span></span><br><span class="line">    const-string v8, <span class="string">"AndiedieHack.currentTimeMillis"</span></span><br><span class="line"></span><br><span class="line">    const-string v9, <span class="string">"AndiedieHack.param"</span></span><br><span class="line"></span><br><span class="line">    const-string v10, <span class="string">"AndiedieHack.b"</span></span><br><span class="line"></span><br><span class="line">    const-string v11, <span class="string">"AndiedieHack.result"</span></span><br><span class="line"></span><br><span class="line">    invoke-static &#123;&#125;, Ljava/lang/System;→currentTimeMillis()J</span><br><span class="line"></span><br><span class="line">    move-result-wide v0</span><br><span class="line"></span><br><span class="line">    invoke-static &#123;v0, v1&#125;, Ljava/lang/String;→valueOf(J)Ljava/lang/String;</span><br><span class="line"></span><br><span class="line">    move-result-object v0</span><br><span class="line">    <span class="comment"># 第一个 Log，输出 v0 的值，即系统当前时间</span></span><br><span class="line">    invoke-static &#123;v8, v0&#125;, Landroid/util/Log;→d(Ljava/lang/String;Ljava/lang/String;)I</span><br><span class="line"></span><br><span class="line">    .line 57</span><br><span class="line">    invoke-static &#123;p1&#125;, Ljava/lang/String;→valueOf(I)Ljava/lang/String;</span><br><span class="line"></span><br><span class="line">    move-result-object v1</span><br><span class="line">    <span class="comment"># 第二个 Log，输出 v1 的值，即目标音量</span></span><br><span class="line">    invoke-static &#123;v9, v1&#125;, Landroid/util/Log;→d(Ljava/lang/String;Ljava/lang/String;)I</span><br><span class="line"></span><br><span class="line">    iget-object v2, p0, Lcom/xiaomi/mitv/phone/tvassistant/b/a;→b:Ljava/lang/String;</span><br><span class="line">    <span class="comment"># 第三个 Log，输出 v2 的值，即 this.b</span></span><br><span class="line">    invoke-static &#123;v10, v2&#125;, Landroid/util/Log;→d(Ljava/lang/String;Ljava/lang/String;)I</span><br><span class="line"></span><br><span class="line">    invoke-direct &#123;p0, v1, v2, v0&#125;, Lcom/xiaomi/mitv/phone/tvassistant/b/a;→a(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;</span><br><span class="line"></span><br><span class="line">    move-result-object v1</span><br><span class="line">    <span class="comment"># 第四个 Log，输出 v1 的值，即签名结果</span></span><br><span class="line">    invoke-static &#123;v11, v1&#125;, Landroid/util/Log;→d(Ljava/lang/String;Ljava/lang/String;)I</span><br></pre></td></tr></table></figure><p>运行修改后的 APP，尝试修改音量，出现以下日志：</p><p><img src="/assets/image-20190211175802805.png" alt="image-20190211175802805"></p><p>这个 <code>this.b</code> 的值是 <code>3c:bd:3e:84:35:31</code></p><p>乍一看就是一个 mac 地址，很有可能就是小米电视的 mac 地址，于是我兴奋地打开路由器界面查询：</p><p><img src="/assets/image-20190211184428074.png" alt="image-20190211184428074"></p><p>不一样🤕！！！</p><p>正当我心灰意冷之时，我猛然发现，这个 mac 地址和刚刚 mDNS 里面获取的 mac 地址一模一样：</p><p><img src="/assets/image-20190211184706127.png" alt="image-20190211184706127"></p><p>之后才发现，<code>3c:bd:3e:84:35:31</code> 是小米电视的以太网口的 mac 地址。</p><p>也就是说，<code>this.b</code> 的值可以通过 mDNS 获取。</p><table><thead><tr><th>任务</th><th>完成</th></tr></thead><tbody><tr><td>计算签名的输入</td><td>✅</td></tr><tr><td>计算签名的算法</td><td>✅</td></tr><tr><td><code>this.b</code> 是什么</td><td>✅</td></tr></tbody></table><h2 id="3-3-验证"><a href="#3-3-验证" class="headerlink" title="3.3. 验证"></a>3.3. 验证</h2><p>接下来对签名算法进行验证：</p><p><img src="/assets/image-20190211184923521.png" alt="image-20190211184923521"></p><p>OK，通过</p><h1 id="4-实现"><a href="#4-实现" class="headerlink" title="4. 实现"></a>4. 实现</h1><p>经过上面的折腾，最终的方案定为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">接打电话</span><br><span class="line">  ↓</span><br><span class="line">通过 mDNS 协议搜索小米电视</span><br><span class="line">    ┣→ 通过 TCP 协议按下确认键</span><br><span class="line">    ┗→ 通过 HTTP 协议获取当前音量</span><br><span class="line">               ┣→ 保存当前音量</span><br><span class="line">               ┗→ 通过 HTTP 设置音量为 0</span><br><span class="line"></span><br><span class="line">电话结束</span><br><span class="line">  ↓</span><br><span class="line">通过 mDNS 协议搜索小米电视</span><br><span class="line">    ┣→ 通过 TCP 协议按下确认键</span><br><span class="line">    ┗→ 读取保存音量 → 通过 HTTP 恢复音量</span><br></pre></td></tr></table></figure><h2 id="4-1-mDNS-实现"><a href="#4-1-mDNS-实现" class="headerlink" title="4.1. mDNS 实现"></a>4.1. mDNS 实现</h2><p>利用 mDNS 获取小米电视信息，这里借助 Android 提供的 <code>NsdManager</code> 实现：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> mNsdManager = getSystemService(Context.NSD_SERVICE) <span class="keyword">as</span> NsdManager</span><br><span class="line"><span class="keyword">val</span> mDiscoveryListener = <span class="keyword">object</span> : NsdManager.DiscoveryListener &#123;</span><br><span class="line">    <span class="keyword">val</span> listen = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onServiceFound</span><span class="params">(serviceInfo: <span class="type">NsdServiceInfo</span>?)</span></span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"ServiceFound: <span class="variable">$serviceInfo</span>"</span>)</span><br><span class="line">        <span class="comment">// 发现服务后，获取服务详细信息</span></span><br><span class="line">        mNsdManager.resolveService(serviceInfo, <span class="keyword">object</span>: NsdManager.ResolveListener &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResolveFailed</span><span class="params">(serviceInfo: <span class="type">NsdServiceInfo</span>?, errorCode: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">                Log.e(TAG, <span class="string">"Resolve failed: <span class="variable">$errorCode</span>"</span>)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onServiceResolved</span><span class="params">(serviceInfo: <span class="type">NsdServiceInfo</span>?)</span></span> &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"Resolve Succeeded. <span class="variable">$serviceInfo</span>"</span>)</span><br><span class="line">                <span class="keyword">if</span> (serviceInfo == <span class="literal">null</span>) <span class="keyword">return</span></span><br><span class="line">                <span class="comment">// ！！服务详细信息！！</span></span><br><span class="line">                serviceInfo</span><br><span class="line">                mNsdManager.stopServiceDiscovery(listen)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStopDiscoveryFailed</span><span class="params">(serviceType: <span class="type">String</span>?, errorCode: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"Stop DNS-SD discovery failed: Error code:<span class="variable">$errorCode</span>"</span>)</span><br><span class="line">        mNsdManager.stopServiceDiscovery(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStartDiscoveryFailed</span><span class="params">(serviceType: <span class="type">String</span>?, errorCode: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"Start DNS-SD discovery failed: Error code:<span class="variable">$errorCode</span>"</span>)</span><br><span class="line">        mNsdManager.stopServiceDiscovery(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onServiceLost</span><span class="params">(serviceInfo: <span class="type">NsdServiceInfo</span>?)</span></span> &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"DNS-SD service lost: <span class="variable">$serviceInfo</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDiscoveryStarted</span><span class="params">(serviceType: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"DNS-SD discovery started"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDiscoveryStopped</span><span class="params">(serviceType: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"DNS-SD discovery stopped: <span class="variable">$serviceType</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意服务类型是 _rc._tcp</span></span><br><span class="line">mNsdManager.discoverServices(<span class="string">"_rc._tcp"</span>, NsdManager.PROTOCOL_DNS_SD, mDiscoveryListener)</span><br></pre></td></tr></table></figure><h2 id="4-2-Socket-实现"><a href="#4-2-Socket-实现" class="headerlink" title="4.2. Socket 实现"></a>4.2. Socket 实现</h2><p>借助 Socket 发送 TCP 包，实现暂停：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> CONFIRM_BYTES = byteArrayOf(<span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x41</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x3a</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x03</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x42</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x1c</span>, <span class="number">0x05</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x06</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x08</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x0a</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x0b</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x03</span>, <span class="number">0x01</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> socket = Socket(serviceInfo.host, serviceInfo.port)</span><br><span class="line"><span class="keyword">val</span> oStream = socket.getOutputStream()</span><br><span class="line"><span class="keyword">val</span> press = CONFIRM_BYTES</span><br><span class="line"><span class="keyword">val</span> up = CONFIRM_BYTES.copyOf()</span><br><span class="line">up[<span class="number">0x13</span>] = <span class="number">0x01</span></span><br><span class="line">oStream.write(press)</span><br><span class="line">oStream.write(up)</span><br><span class="line">oStream.flush()</span><br></pre></td></tr></table></figure><h2 id="4-3-监听电话状态"><a href="#4-3-监听电话状态" class="headerlink" title="4.3. 监听电话状态"></a>4.3. 监听电话状态</h2><p>添加权限</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.READ_PHONE_STATE"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>注意这个权限必须运行时请求：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> const <span class="keyword">val</span> PERMISSIONS_REQUEST = <span class="number">852</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">hasPermissions</span><span class="params">(permissions: <span class="type">List</span>&lt;<span class="type">String</span>&gt;)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (permission <span class="keyword">in</span> permissions) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ActivityCompat.checkSelfPermission(<span class="keyword">this</span>, permission) != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">checkPermissions</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> permissions = mutableListOf&lt;String&gt;(Manifest.permission.READ_PHONE_STATE)</span><br><span class="line">    <span class="keyword">if</span> (!hasPermissions(permissions)) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"Permissions missing"</span>)</span><br><span class="line">        ActivityCompat.requestPermissions(<span class="keyword">this</span>, permissions.toTypedArray(), PERMISSIONS_REQUEST)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"Permissions granted"</span>)</span><br><span class="line">        permission = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onRequestPermissionsResult</span><span class="params">(requestCode: <span class="type">Int</span>, permissions: <span class="type">Array</span>&lt;<span class="type">out</span> <span class="type">String</span>&gt;, grantResults: <span class="type">IntArray</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (grantResults.isEmpty()) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">when</span> (requestCode) &#123;</span><br><span class="line">        PERMISSIONS_REQUEST -&gt; &#123;</span><br><span class="line">            <span class="keyword">var</span> flag = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">for</span> (result <span class="keyword">in</span> grantResults) &#123;</span><br><span class="line">                <span class="keyword">if</span> (result != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">                    flag = <span class="literal">false</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            permission = <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"Request permissions success"</span>)</span><br><span class="line">                <span class="literal">true</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"Request permissions failed"</span>)</span><br><span class="line">                <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务实现：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> phoneStateReceiver = <span class="keyword">object</span> : BroadcastReceiver() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> lastIdle = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onReceive</span><span class="params">(context: <span class="type">Context</span>?, intent: <span class="type">Intent</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (context == <span class="literal">null</span> || intent == <span class="literal">null</span>) <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">when</span> (intent.action) &#123;</span><br><span class="line">            TelephonyManager.ACTION_PHONE_STATE_CHANGED -&gt; &#123;</span><br><span class="line">                <span class="keyword">val</span> tManager = context.getSystemService(TELEPHONY_SERVICE) <span class="keyword">as</span> TelephonyManager</span><br><span class="line">                <span class="keyword">if</span> (tManager.callState == TelephonyManager.CALL_STATE_IDLE) &#123;</span><br><span class="line">                    lastIdle = <span class="literal">true</span></span><br><span class="line">                    <span class="comment">// 电话结束</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lastIdle) &#123;</span><br><span class="line">                    lastIdle = <span class="literal">false</span></span><br><span class="line">                    <span class="comment">// 接打电话</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">register</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.registerReceiver(phoneStateReceiver, IntentFilter(TelephonyManager.ACTION_PHONE_STATE_CHANGED))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-坑"><a href="#5-坑" class="headerlink" title="5. 坑"></a>5. 坑</h1><h2 id="5-1-刚连接-WiFi-时-Socket-Timeout"><a href="#5-1-刚连接-WiFi-时-Socket-Timeout" class="headerlink" title="5.1. 刚连接 WiFi 时 Socket Timeout"></a>5.1. 刚连接 WiFi 时 Socket Timeout</h2><p>如果在刚刚连接 WiFi 的一瞬间连接 Socket，会出现 <code>connect failed: ETIMEDOUT</code> 的错误</p><p>为了避免这样的错误，得进行自动重连：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        socket = Socket(serviceInfo.host, serviceInfo.port)</span><br><span class="line">        Log.d(TAG, <span class="string">"Socket connected: <span class="subst">$&#123;serviceInfo.host&#125;</span>:<span class="subst">$&#123;serviceInfo.port&#125;</span>"</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (err : ConnectException) &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>)</span><br><span class="line">        Log.e(TAG, err.toString())</span><br><span class="line">        Log.d(TAG, <span class="string">"Retrying"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-2-RxJava-自动回收"><a href="#5-2-RxJava-自动回收" class="headerlink" title="5.2. RxJava 自动回收"></a>5.2. RxJava 自动回收</h2><p>RxJava 中一些任务如果没有回收，会有一些潜在的问题。</p><p>例如，如果在某个 Activity 中使用了一个用于网络请求的 RxJava，此时如果 Activity 被系统关闭，会造成内存泄漏。</p><p>以下代码可以实现自动回收：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> compositeDisposable = new CompositeDisposable();</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> disposable = Observable.just(<span class="number">1</span>)</span><br><span class="line">        .subscribeOn(Schedulers.io())</span><br><span class="line">        .subscribe(number -&gt; Log.d(number));</span><br><span class="line"></span><br><span class="line">compositeDisposable.add(disposable);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 onDestroy 时调用</span></span><br><span class="line">compositeDisposable.dispose();</span><br></pre></td></tr></table></figure><p>更多详情，参照<a href="https://stackoverflow.com/questions/49522619/the-result-of-subscribe-is-not-used" target="_blank" rel="noopener">相关问题</a>。</p><h2 id="5-3-服务始终保持运行"><a href="#5-3-服务始终保持运行" class="headerlink" title="5.3. 服务始终保持运行"></a>5.3. 服务始终保持运行</h2><p>本来可以直接用普通的 <code>Service</code> 来搞定，但是 <code>Service</code> 会不定时被系统回收，且国内安卓市场混乱，很容易被进制后台，所以这里采用前台服务 <code>ForegroundService</code> 来保持服务始终运行。</p><p>要注意的是，前台服务是在服务运行过程中启动的，而非启动服务的时候；另外前台服务运行中，通知栏会有无法关闭的通知来告知用户服务仍然在运行。</p><p>声明服务：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">service</span> <span class="attr">android:name</span>=<span class="string">".PhoneStateReceiverService"</span> <span class="attr">android:exported</span>=<span class="string">"false"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>声明权限：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.FOREGROUND_SERVICE"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>注意这个权限必须运行时请求，同上述 <code>android.permission.READ_PHONE_STATE</code> 权限。</p><p>服务实现细节：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> TAG = <span class="string">"TVPause."</span> + PhoneStateReceiverService::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>.<span class="title">simpleName</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneStateReceiverService</span> : <span class="type">Service</span></span>() &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> const <span class="keyword">val</span> CHANNEL_ID = <span class="string">"cn.andiedie.TVPause.PhoneStateReceiverService.CHANNEL"</span></span><br><span class="line">        <span class="keyword">private</span> const <span class="keyword">val</span> NOTIFICATION_ID = <span class="number">19210</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate()</span><br><span class="line">        <span class="comment">// Android O 开始需要管理通知的频道</span></span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">            <span class="keyword">val</span> name = getText(R.string.channel_name)</span><br><span class="line">            <span class="keyword">val</span> description = getText(R.string.channel_description).toString()</span><br><span class="line">            <span class="keyword">val</span> importance = NotificationManager.IMPORTANCE_DEFAULT</span><br><span class="line">            <span class="keyword">val</span> mChannel = NotificationChannel(CHANNEL_ID, name, importance)</span><br><span class="line">            mChannel.description = description</span><br><span class="line">            <span class="keyword">val</span> notificationManager = getSystemService(Context.NOTIFICATION_SERVICE) <span class="keyword">as</span> NotificationManager</span><br><span class="line">            notificationManager.createNotificationChannel(mChannel)</span><br><span class="line">        &#125;</span><br><span class="line">        Log.d(TAG, <span class="string">"PhoneStateReceiverService create"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">register</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> builder = <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">            Notification.Builder(<span class="keyword">this</span>, CHANNEL_ID)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Notification.Builder(<span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> notification = builder.setContentTitle(getText(R.string.notification_title))</span><br><span class="line">            .setContentText(getText(R.string.notification_message))</span><br><span class="line">            .setSmallIcon(R.mipmap.ic_launcher)</span><br><span class="line">            .build()</span><br><span class="line">        startForeground(NOTIFICATION_ID, notification)</span><br><span class="line">        <span class="comment">// 从这开始 服务就保持一直运行</span></span><br><span class="line">        <span class="comment">// 将需要长时间运行的服务，例如电话状态接收函数放在这里注册</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">unregister</span><span class="params">()</span></span> &#123;</span><br><span class="line">        unregisterReceiver(phoneStateReceiver)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBind</span><span class="params">(intent: <span class="type">Intent</span>?)</span></span>: IBinder? &#123; <span class="keyword">return</span> <span class="literal">null</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-4-Android-P-明文传输错误"><a href="#5-4-Android-P-明文传输错误" class="headerlink" title="5.4. Android P 明文传输错误"></a>5.4. Android P 明文传输错误</h2><p>Android 9.0 (API level 28) 开始默认禁止明文传输，因此 HTTP 会出错。</p><p>需要手动开启：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.INTERNET"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">        <span class="attr">...</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:networkSecurityConfig</span>=<span class="string">"@xml/network_security_config"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">...</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><p>更多详情，参照<a href="https://stackoverflow.com/questions/45940861/android-8-cleartext-http-traffic-not-permitted" target="_blank" rel="noopener">相关问题</a>。</p><h2 id="5-5-关于屏幕旋转"><a href="#5-5-关于屏幕旋转" class="headerlink" title="5.5. 关于屏幕旋转"></a>5.5. 关于屏幕旋转</h2><p>Android 在屏幕旋转的过程中，默认会销毁当前 Activity，然后重新渲染一个新的 Activity。可以通过配置修改这个表现。</p><p>保持竖屏：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">                <span class="attr">android:screenOrientation</span>=<span class="string">"portrait"</span></span></span><br><span class="line"><span class="tag">                &gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><p>更多详情，参考<a href="https://blog.csdn.net/leejizhou/article/details/51233342" target="_blank" rel="noopener">这个链接</a>。</p><h1 id="6-效果"><a href="#6-效果" class="headerlink" title="6. 效果"></a>6. 效果</h1><p><img src="/assets/image-20190211184923522.gif" alt="image-20190211184923522"></p><p>请无视电视剧内容和手机来电头像🤠。</p><h1 id="7-下一步"><a href="#7-下一步" class="headerlink" title="7. 下一步"></a>7. 下一步</h1><p>下一步可以考虑在电视装一个服务端，这样就可以非常详细地获得当前电视的运行情况，各种连接、操作也可以自定义搞定。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近家里有个小的需求，就是希望在接打电话的时候能够自动暂停电视节目。于是我就写了一个简单的工具，这篇博客主要记录实现的过程、遇到的问题以及一些小的心得。开源地址：&lt;a href=&quot;https://github.com/Andiedie/TVPause&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;TVPause&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Development" scheme="http://blog.andiedie.cn/categories/Development/"/>
    
    
  </entry>
  
  <entry>
    <title>Android 反编译、修改、重打包与签名</title>
    <link href="http://blog.andiedie.cn/posts/552a/"/>
    <id>http://blog.andiedie.cn/posts/552a/</id>
    <published>2019-02-11T06:39:49.000Z</published>
    <updated>2019-05-10T13:08:07.541Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这篇博客主要介绍如何使用 Apktool、dex2jar、jd-gui等工具反编译 Android APP、修改源码、重新打包并签名。</p><a id="more"></a><h1 id="1-工具安装"><a href="#1-工具安装" class="headerlink" title="1. 工具安装"></a>1. 工具安装</h1><h2 id="1-1-Apktool"><a href="#1-1-Apktool" class="headerlink" title="1.1. Apktool"></a>1.1. Apktool</h2><p>Apktool 主要用于反编译和重编译 APK 文件。</p><p>Windows 和 Linux 安装方法参照：<a href="https://ibotpeaches.github.io/Apktool/install/" target="_blank" rel="noopener">官方指南</a></p><p>macOS 安装方法如下：</p><ul><li>右键保存<a href="https://raw.githubusercontent.com/iBotPeaches/Apktool/master/scripts/osx/apktool" target="_blank" rel="noopener">启动脚本</a>，命名为 <code>apktool</code></li><li>下载<a href="https://bitbucket.org/iBotPeaches/apktool/downloads/" target="_blank" rel="noopener">最新版本</a>的 Apktool，命名为 <code>apktool.jar</code></li><li>将 <code>apktool</code> 和 <code>apktool.jar</code> 移动到 <code>/usr/local/bin</code> 目录下</li><li>使用 <code>chmod +x apktool</code> 和 <code>chmod +x apktool.jar</code> 添加运行权限</li><li>在命令行直接运行命令 <code>apktool</code> 即可，安装完成</li></ul><h2 id="1-2-dex2jar"><a href="#1-2-dex2jar" class="headerlink" title="1.2. dex2jar"></a>1.2. dex2jar</h2><p>dex2jar 主要用于将 dex 文件转为 jar 文件</p><p>从 <a href="https://github.com/pxb1988/dex2jar/releases" target="_blank" rel="noopener">GitHub</a> 下载最新版本，并解压。运行解压后目录下的 <code>d2j-dex2jar.sh</code> 或 <code>d2j-dex2jar.bat</code> 即可。</p><h2 id="1-3-jd-gui"><a href="#1-3-jd-gui" class="headerlink" title="1.3. jd-gui"></a>1.3. jd-gui</h2><p>jd-gui 主要用来可视化 jar 文件。</p><p>从 <a href="https://github.com/java-decompiler/jd-gui/releases" target="_blank" rel="noopener">GitHub</a> 下载最新版本，并解压。运行解压后目录下的 <code>JD-GUI</code> 即可。</p><p><strong>macOS 下注意</strong>：</p><p>如果 jd-gui 无法打开，编辑 <code>JD-GUI.app/Contents/MacOS/universalJavaApplicationStub.sh</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span> <span class="string">"<span class="variable">$JAVACMD</span>"</span> \</span><br><span class="line">-cp <span class="string">"<span class="variable">$&#123;JVMClassPath&#125;</span>"</span> \</span><br><span class="line">-Xdock:icon=<span class="string">"<span class="variable">$&#123;ResourcesFolder&#125;</span>/<span class="variable">$&#123;CFBundleIconFile&#125;</span>"</span> \</span><br><span class="line">-Xdock:name=<span class="string">"<span class="variable">$&#123;CFBundleName&#125;</span>"</span> \</span><br><span class="line"><span class="comment">## ----- 添加这两行 -----</span></span><br><span class="line">--add-opens java.base/jdk.internal.loader=ALL-UNNAMED \</span><br><span class="line">--add-opens jdk.zipfs/jdk.nio.zipfs=ALL-UNNAMED \</span><br><span class="line"><span class="comment">## --------------------</span></span><br><span class="line"><span class="variable">$&#123;JVMOptions:+$JVMOptions &#125;</span>\</span><br><span class="line"><span class="variable">$&#123;JVMDefaultOptions:+$JVMDefaultOptions &#125;</span>\</span><br><span class="line"><span class="variable">$&#123;JVMMainClass&#125;</span>\</span><br><span class="line"><span class="variable">$&#123;JVMArguments:+ $JVMArguments&#125;</span></span><br></pre></td></tr></table></figure><p>详见 <a href="https://github.com/java-decompiler/jd-gui/issues/196" target="_blank" rel="noopener">issue</a></p><h1 id="2-查看源码"><a href="#2-查看源码" class="headerlink" title="2. 查看源码"></a>2. 查看源码</h1><p>以小米投屏神器 APP 为例。</p><p>运行 d2j-dex2jar.sh 将 APK 中的 dex 文件转为 jar 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./d2j-dex2jar.sh mi.apk</span><br><span class="line">dex2jar mi.apk -&gt; ./mi-dex2jar.jar</span><br></pre></td></tr></table></figure><p>打开 jd-gui，将 <code>mi-dex2jar.jar</code> 拖进去，即可看到反编译后的源码。</p><p><img src="/assets/image-20190211172815715.png" alt="image-20190211172815715"></p><h1 id="3-修改源码"><a href="#3-修改源码" class="headerlink" title="3. 修改源码"></a>3. 修改源码</h1><p>这里以增加 Log 为修改源码的例子。</p><p>jd-gui 只能查看源码，但是无法修改。要修改源码，只能修改 <code>smali</code> 文件，它类似于汇编，但是要简单很多。</p><p>首先得使用 apktool 进行反编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apktool d mi.apk -o mi</span><br></pre></td></tr></table></figure><p>这里将 <code>mi.apk</code> 进行反编译并将结果放到 <code>mi</code> 目录中。</p><p>首先找到需要添加 Log 的位置，建议在 jd-gui 中寻找，然后在 <code>mi</code> 目录中定位。</p><p>例如以下 <code>class</code> 和 <code>smali</code> 的对应关系</p><ul><li><code>mi-dex2jar.jar!/com/xiaomi/mitv/phone/tvassistant/b/a.class</code></li><li><code>mi/smali/com/xiaomi/mitv/phone/tvassistant/b/a.smali</code></li></ul><p>打开 <code>a.class</code> 和  <code>a.smali</code>，首先看 <code>java</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">(<span class="keyword">int</span> paramInt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    String str1 = String.valueOf(System.currentTimeMillis());</span><br><span class="line">    String str2 = a(String.valueOf(paramInt), <span class="keyword">this</span>.b, str1);</span><br><span class="line">    <span class="keyword">new</span> c(<span class="keyword">this</span>.d, String.format(<span class="string">"http://%s:6095/general?action=setVolum&amp;volum=%d&amp;ts=%s&amp;sign=%s"</span>, <span class="keyword">new</span> Object[] &#123; <span class="keyword">this</span>.a, Integer.valueOf(paramInt), str1, str2 &#125;), <span class="keyword">new</span> c.a()</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">(<span class="keyword">int</span> paramAnonymousInt, String paramAnonymousString)</span> </span>&#123;&#125;</span><br><span class="line">          &#125;).d();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的 <code>smali</code> 文件内容，为了简单，我只提取了部分内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">.method public a(I)V</span><br><span class="line">    <span class="comment"># a 是方法，p0 = this</span></span><br><span class="line">    <span class="comment"># a 接收一个参数, p1 = paramInt'</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 定义了 8 个寄存器</span></span><br><span class="line">    .locals 8</span><br><span class="line"></span><br><span class="line">    .prologue</span><br><span class="line">    .line 55</span><br><span class="line">    <span class="comment"># 获取系统当前时间</span></span><br><span class="line">    invoke-static &#123;&#125;, Ljava/lang/System;-&gt;currentTimeMillis()J</span><br><span class="line">    <span class="comment"># 结果赋值给 v0</span></span><br><span class="line">    move-result-wide v0</span><br><span class="line">    <span class="comment"># 调用 String.valueOf 方法，将 v0 转为字符串</span></span><br><span class="line">    invoke-static &#123;v0, v1&#125;, Ljava/lang/String;-&gt;valueOf(J)Ljava/lang/String;</span><br><span class="line">    <span class="comment"># 结果赋值给 v0</span></span><br><span class="line">    move-result-object v0</span><br><span class="line">    <span class="comment"># 到这一步</span></span><br><span class="line">    <span class="comment"># String str1 = String.valueOf(System.currentTimeMillis());</span></span><br><span class="line">    <span class="comment"># 执行完了</span></span><br><span class="line"></span><br><span class="line">    .line 57</span><br><span class="line">    <span class="comment"># 调用 String.valueOf 方法 p1 转为字符串</span></span><br><span class="line">    invoke-static &#123;p1&#125;, Ljava/lang/String;-&gt;valueOf(I)Ljava/lang/String;</span><br><span class="line">    <span class="comment"># 结果赋值给 v1</span></span><br><span class="line">    move-result-object v1</span><br><span class="line"><span class="comment"># 获取 this.b，也就是从 p1 中获取 b，并赋值给 v2</span></span><br><span class="line">    iget-object v2, p0, Lcom/xiaomi/mitv/phone/tvassistant/b/a;-&gt;b:Ljava/lang/String;</span><br><span class="line">    <span class="comment"># 将 v1，v2，v0 作为参数调用方法 a，并传递 p0 作为 this</span></span><br><span class="line">    invoke-direct &#123;p0, v1, v2, v0&#125;, Lcom/xiaomi/mitv/phone/tvassistant/b/a;-&gt;a(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;</span><br><span class="line">    <span class="comment"># 将结果赋值给 v1</span></span><br><span class="line">    move-result-object v1</span><br><span class="line">    <span class="comment"># 到这一步</span></span><br><span class="line">    <span class="comment"># String str2 = a(String.valueOf(paramInt), this.b, str1);</span></span><br><span class="line">    <span class="comment"># 执行完了</span></span><br><span class="line">    </span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>假设我们想要得知其中 <code>this.b</code> 的值，可以这样添加 Log：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">.method public a(I)V</span><br><span class="line">    <span class="comment"># 额外定义 4 个寄存器用于存储 TAG</span></span><br><span class="line">    .locals 12</span><br><span class="line"></span><br><span class="line">    .prologue</span><br><span class="line">    .line 55</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置初始化TAG</span></span><br><span class="line">    const-string v8, <span class="string">"AndiedieHack.currentTimeMillis"</span></span><br><span class="line"></span><br><span class="line">    const-string v9, <span class="string">"AndiedieHack.param"</span></span><br><span class="line"></span><br><span class="line">    const-string v10, <span class="string">"AndiedieHack.b"</span></span><br><span class="line"></span><br><span class="line">    const-string v11, <span class="string">"AndiedieHack.result"</span></span><br><span class="line"></span><br><span class="line">    invoke-static &#123;&#125;, Ljava/lang/System;-&gt;currentTimeMillis()J</span><br><span class="line"></span><br><span class="line">    move-result-wide v0</span><br><span class="line"></span><br><span class="line">    invoke-static &#123;v0, v1&#125;, Ljava/lang/String;-&gt;valueOf(J)Ljava/lang/String;</span><br><span class="line"></span><br><span class="line">    move-result-object v0</span><br><span class="line">    <span class="comment"># 第一个 Log，使用 v8 作为 TAG，输出 v0 的值，即系统当前时间</span></span><br><span class="line">    invoke-static &#123;v8, v0&#125;, Landroid/util/Log;-&gt;d(Ljava/lang/String;Ljava/lang/String;)I</span><br><span class="line"></span><br><span class="line">    .line 57</span><br><span class="line">    invoke-static &#123;p1&#125;, Ljava/lang/String;-&gt;valueOf(I)Ljava/lang/String;</span><br><span class="line"></span><br><span class="line">    move-result-object v1</span><br><span class="line">    <span class="comment"># 第二个 Log，使用 v9 作为 TAG，输出 v1 的值</span></span><br><span class="line">    <span class="comment"># v1 是 p1 的字符串形式，p1 是函数参数</span></span><br><span class="line">    invoke-static &#123;v9, v1&#125;, Landroid/util/Log;-&gt;d(Ljava/lang/String;Ljava/lang/String;)I</span><br><span class="line"></span><br><span class="line">    iget-object v2, p0, Lcom/xiaomi/mitv/phone/tvassistant/b/a;-&gt;b:Ljava/lang/String;</span><br><span class="line">    <span class="comment"># 第三个 Log，使用 v10 作为 TAG，输出 v2 的值，即 this.b</span></span><br><span class="line">    invoke-static &#123;v10, v2&#125;, Landroid/util/Log;-&gt;d(Ljava/lang/String;Ljava/lang/String;)I</span><br><span class="line"></span><br><span class="line">    invoke-direct &#123;p0, v1, v2, v0&#125;, Lcom/xiaomi/mitv/phone/tvassistant/b/a;-&gt;a(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;</span><br><span class="line"></span><br><span class="line">    move-result-object v1</span><br><span class="line">    <span class="comment"># 第四个 Log，使用 v11 作为 TAG，输出 v1 的值，即 str2</span></span><br><span class="line">    invoke-static &#123;v11, v1&#125;, Landroid/util/Log;-&gt;d(Ljava/lang/String;Ljava/lang/String;)I</span><br></pre></td></tr></table></figure><p>到这一步，源码修改完成。接下来进行重新打包。</p><h1 id="3-重新打包与签名"><a href="#3-重新打包与签名" class="headerlink" title="3. 重新打包与签名"></a>3. 重新打包与签名</h1><p>将修改后的内容重新打包为 APK：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apktool b mi -o unsigned.apk</span><br></pre></td></tr></table></figure><p>打包之后的 <code>unsigned.apk</code> 是没有签名的，无法安装。</p><p>签名需要使用一个 <code>keystore</code>，可以直接使用 Android Studio 为我们生成的 debug 用 keystore。</p><p>位置在 <code>用户目录/.android/debug.keystore</code>，<code>alias</code> 是 <code>androiddebugkey</code>，密码是 <code>android</code></p><p>签名命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jarsigner -keystore debug.keystore -signedjar signed.apk  unsigned.apk  androiddebugkey</span><br></pre></td></tr></table></figure><p>输入密码即可。</p><h1 id="4-测试"><a href="#4-测试" class="headerlink" title="4. 测试"></a>4. 测试</h1><p>在手机上安装 <code>signed.apk</code>，注意如果之前已经安装了投屏神器，需要先卸载，因为两者的签名不一致。</p><p>运行 APP，调整音量，可以看到以下 Log：</p><p><img src="/assets/image-20190211175802805.png" alt="image-20190211175802805"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇博客主要介绍如何使用 Apktool、dex2jar、jd-gui等工具反编译 Android APP、修改源码、重新打包并签名。&lt;/p&gt;
    
    </summary>
    
      <category term="Tutorial" scheme="http://blog.andiedie.cn/categories/Tutorial/"/>
    
    
  </entry>
  
  <entry>
    <title>移动设备抓包</title>
    <link href="http://blog.andiedie.cn/posts/cc60/"/>
    <id>http://blog.andiedie.cn/posts/cc60/</id>
    <published>2019-02-02T05:46:34.000Z</published>
    <updated>2019-05-10T13:08:07.548Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文主要以 iOS 为例，演示如何使用 Charles 和 Wireshark 在移动设备上抓取 HTTPS、HTTPS、TCP 等协议的数据包。</p><a id="more"></a><p>以下称 <code>PC</code> 为抓包所用的计算机，<code>手机</code>为被抓包的移动设备。</p><h1 id="1-使用-Charles-抓取-HTTP"><a href="#1-使用-Charles-抓取-HTTP" class="headerlink" title="1. 使用 Charles 抓取 HTTP"></a>1. 使用 Charles 抓取 HTTP</h1><p>首先安装 Charles，下载地址：<a href="https://www.charlesproxy.com/download/" target="_blank" rel="noopener">官网</a>。</p><p>使用 Charles 抓包要求 PC 和 手机必须位于同一个局域网下。</p><h2 id="1-1-配置-Charles"><a href="#1-1-配置-Charles" class="headerlink" title="1.1. 配置 Charles"></a>1.1. 配置 Charles</h2><p>打开 Charles，菜单 <code>Proxy &gt; Proxy Settings...</code> 进入代理设置，打开代理服务器。可以指定代理服务器运行的端口，这里使用默认端口 <code>8888</code>。</p><p><img src="/assets/image-20190202135416291.png" alt="image-20190202135416291"></p><p>接下来获取 Charles 代理服务器局域网 IP，也就是本机在局域网的 IP。macOS 可以打开 <code>System Preferences &gt; Network</code> 中查看，当然也可以运行 <code>ifconfig</code> 查看。</p><p><img src="/assets/image-20190202140155578.png" alt="image-20190202140155578"></p><p>至此，我们知道了 Charles 的代理服务器的地址是 <code>192.168.31.110:8888</code>。</p><h2 id="1-2-配置手机"><a href="#1-2-配置手机" class="headerlink" title="1.2. 配置手机"></a>1.2. 配置手机</h2><p>手机连接 PC 所在局域网的 WiFi，并配置代理服务器。iOS 示例如下：</p><p><img src="/assets/IMG_89C954C61847-1.jpeg" alt="IMG_89C954C61847-1"></p><h2 id="1-3-开始抓包"><a href="#1-3-开始抓包" class="headerlink" title="1.3. 开始抓包"></a>1.3. 开始抓包</h2><p>此时直接从手机发起任何 HTTP 请求即可，PC 上的 Charles 会显示所有 HTTP 数据包。若想要停止抓包，请关闭 Charles 并在手机上取消使用代理服务器。</p><p><img src="/assets/image-20190202141643329.png" alt="image-20190202141643329"></p><h2 id="2-使用-Charles-抓取-HTTPS"><a href="#2-使用-Charles-抓取-HTTPS" class="headerlink" title="2. 使用 Charles 抓取 HTTPS"></a>2. 使用 Charles 抓取 HTTPS</h2><p>为了使 Charles 能够成为中间人抓取 HTTPS，必须首先安装并信任 Charles 签发的 CA 证书。</p><h2 id="2-1-设置代理服务器"><a href="#2-1-设置代理服务器" class="headerlink" title="2.1. 设置代理服务器"></a>2.1. 设置代理服务器</h2><p>首先按照上一步提到的步骤，打开 Charles 的代理服务器，并配置手机连接该代理服务器。只有这样，才能下载 Charles 签发的证书。</p><h2 id="2-2-安装证书"><a href="#2-2-安装证书" class="headerlink" title="2.2. 安装证书"></a>2.2. 安装证书</h2><p>在手机上访问网页 <code>chls.pro/ssl</code>，iOS 上注意使用 <code>Safari</code> 打开该页面才能正常显示证书。</p><p><img src="/assets/IMG_F9AF399C1462-1.jpeg" alt="IMG_F9AF399C1462-1"></p><p>注意，安装时需要输入手机密码。</p><h2 id="2-3-信任证书"><a href="#2-3-信任证书" class="headerlink" title="2.3. 信任证书"></a>2.3. 信任证书</h2><p>iOS 进入<code>设置 &gt; 通用 &gt; 关于本机 &gt; 证书信任设置</code>，并设置对 Charles 证书的信任。</p><p><img src="/assets/IMG_DB6EB44D9B15-1.jpeg" alt="IMG_DB6EB44D9B15-1"></p><h2 id="2-4-配置-Charles"><a href="#2-4-配置-Charles" class="headerlink" title="2.4. 配置 Charles"></a>2.4. 配置 Charles</h2><p>默认 Charles 不会代理任何 HTTPS 请求，需要在 <code>Proxy &gt; SSL Proxying Setting...</code> 中打开 HTTPS 代理：</p><p><img src="/assets/image-20190202143046675.png" alt="image-20190202143046675"></p><p>注意，Charles 代理 HTTPS 采用白名单机制，只有名单中的地址才会被代理 HTTPS 协议。如果想代理全部地址的 HTTPS，在添加地址时只需要在 <code>Host</code> 输入 <code>*</code> 即可。</p><p><img src="/assets/image-20190202143212206.png" alt="image-20190202143212206"></p><h2 id="2-5-开始抓包"><a href="#2-5-开始抓包" class="headerlink" title="2.5. 开始抓包"></a>2.5. 开始抓包</h2><p>此时直接从手机发起任何 HTTPS 请求即可，PC 上的 Charles 会显示所有 HTTPS 数据包。若想要停止抓包，请关闭 Charles 并在手机上取消使用代理服务器。</p><p><img src="/assets/image-20190202143459351.png" alt="image-20190202143459351"></p><h1 id="3-使用-Wireshark-抓取"><a href="#3-使用-Wireshark-抓取" class="headerlink" title="3. 使用 Wireshark 抓取"></a>3. 使用 Wireshark 抓取</h1><p>首先安装 Wireshark，下载地址：<a href="https://www.wireshark.org/download.html" target="_blank" rel="noopener">官网</a>。</p><p>Wireshark 可以监听任何网卡中的所有网络流量，因此既然我们要监听手机上的网络流量，就需要建立一个映射到手机上的虚拟网卡。</p><h2 id="3-1-安装-Xcode"><a href="#3-1-安装-Xcode" class="headerlink" title="3.1. 安装 Xcode"></a>3.1. 安装 <code>Xcode</code></h2><p>由于建立虚拟网卡需要使用命令 <code>rvictl</code>，这是 <code>Xcode</code> 工具链之一，所以需要安装 <code>Xcode</code>。可以从从 App Store 或 <a href="https://itunes.apple.com/cn/app/xcode/id497799835?l=en&amp;mt=12" target="_blank" rel="noopener">这里</a> 下载并安装 <code>Xcode</code>。</p><p>下载并安装之后，请至少运行一次 <code>Xcode</code> ，<code>Xcode</code> 会自动安装必要的工具。</p><p><img src="/assets/Screen Shot 2019-02-02 at 14.58.32.png" alt="Screen Shot 2019-02-02 at 14.58.32"></p><h2 id="3-2-获取设备-UDID"><a href="#3-2-获取设备-UDID" class="headerlink" title="3.2. 获取设备 UDID"></a>3.2. 获取设备 <code>UDID</code></h2><p>首先，需要获取设备的 <code>UDID</code>。将手机通过数据线连接电脑，打开 iTunes，单击 iPhone 的序列号：</p><p><img src="/assets/image-20190202145132368.png" alt="image-20190202145132368"></p><p>设备的 <code>UDID</code> 就会出现，右键可以复制：</p><p><img src="/assets/image-20190202145246877.png" alt="image-20190202145246877"></p><h2 id="3-3-配置虚拟网卡"><a href="#3-3-配置虚拟网卡" class="headerlink" title="3.3. 配置虚拟网卡"></a>3.3. 配置虚拟网卡</h2><p>在终端运行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ rvictl -s [YOUR UDID]</span><br><span class="line"></span><br><span class="line">Starting device [YOUR UDID] [SUCCEEDED] with interface rvi0</span><br></pre></td></tr></table></figure><p>可以看到，虚拟网卡 <code>rvi0</code> 已经建立。</p><h2 id="3-4-开始抓包"><a href="#3-4-开始抓包" class="headerlink" title="3.4. 开始抓包"></a>3.4. 开始抓包</h2><p>打开 Wireshark，选择虚拟网卡 <code>rvi0</code> 即可开始抓包。</p><p><img src="/assets/image-20190202151027197.png" alt="image-20190202151027197"></p><p>在手机上发送任意数据包即可。</p><p><img src="/assets/image-20190202152150992.png" alt="image-20190202152150992"></p><h2 id="3-5-停止抓包"><a href="#3-5-停止抓包" class="headerlink" title="3.5. 停止抓包"></a>3.5. 停止抓包</h2><p>停止抓包后，除了关闭 Wireshark，还需要移除虚拟网卡。</p><p>在终端运行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ rvictl -x [YOUR UDID]</span><br><span class="line"></span><br><span class="line">Stopping device [YOUR UDID] [SUCCEEDED]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要以 iOS 为例，演示如何使用 Charles 和 Wireshark 在移动设备上抓取 HTTPS、HTTPS、TCP 等协议的数据包。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Bilibili Watchlater Plus : 让 B 站的稍后再看更好用</title>
    <link href="http://blog.andiedie.cn/posts/7a6d/"/>
    <id>http://blog.andiedie.cn/posts/7a6d/</id>
    <published>2019-01-25T11:32:36.000Z</published>
    <updated>2019-05-10T13:08:07.542Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>B 站的稍后再看功能明显是一个半成品，有许多不完善的地方，其中最致命的就是无法加入和播放番剧。最近我终于忍受不了它的诸多问题，着手开发了一个油猴脚本 Bilibili Watchlater Plus，对稍后再看功能进行了一番改造。开源地址：<a href="https://github.com/Andiedie/bilibili-watchlater-plus" target="_blank" rel="noopener">bilibili-watchlater-plus</a>。</p><a id="more"></a><h1 id="1-问题"><a href="#1-问题" class="headerlink" title="1. 问题"></a>1. 问题</h1><p>B 站的稍后再看功能主要有三点让我觉得不能忍受：</p><ol><li><p>无法将番剧加入稍后再看。</p><p><img src="/assets/image-20190125195221887.png" alt="image-20190125195221887"></p></li><li><p>即使通过一些特别的方式将番剧加入了稍后再看，也无法播放。</p><p><img src="/assets/image-20190125203812434.png" alt="image-20190125203812434"></p></li><li><p>稍后再看按钮没有初始状态。</p><p>一句话总结理想状态就是，<strong>已加入的视频初始显示勾选，没加入的视频初始不勾选；点击未勾选的按钮，将视频加入稍后再看；点击已勾选的按钮，将视频移出稍后再看</strong>。</p><p>然后 B 站目前无论一个视频有没有被加入稍后再看，它的按钮都是同一个初始状态，也就是说下面的第一张图。</p><p>没加入稍后再看的视频的默认初始状态：</p><p><img src="/assets/image-20190125210925839.png" alt="image-20190125210925839"></p><p>已被加入稍后再看的视频的<strong>理想初始状态</strong>：</p><p><img src="/assets/image-20190125211007688.png" alt="image-20190125211007688"></p></li></ol><h1 id="2-初级阶段"><a href="#2-初级阶段" class="headerlink" title="2. 初级阶段"></a>2. 初级阶段</h1><p>在开发这个正式版本之前，我曾写过一个临时用用的版本，主要作用于首页右上角的动态悬浮窗，因为那是我用的最多的地方。</p><p>这个版本可以从这里获取：<a href="https://github.com/Andiedie/bilibili-watchlater-plus/blob/801a7ce7e5f26ac4b136f06cc8767283ed3835f4/bilibili-watchlater-plus.user.js" target="_blank" rel="noopener">Bilibili Watchlater Plus 0.0.1</a>。</p><p>当时解决了在动态悬浮窗上已经可以将番剧加入稍后再看，稍后再看按钮有初始状态。对于在稍后再看中的番剧视频，则是采用直接跳转到播放链接的方式解决。</p><p>上述的临时版本让我在一段时间内有了比较舒适的使用体验，但是近段时间 B 站更改了一些 UI 和 API 接口，原来的脚本失效了。正巧假期时间比较充裕，我就借此机会开发了一个比较完整的版本。</p><h1 id="3-实现"><a href="#3-实现" class="headerlink" title="3. 实现"></a>3. 实现</h1><h2 id="3-1-如何实现"><a href="#3-1-如何实现" class="headerlink" title="3.1. 如何实现"></a>3.1. 如何实现</h2><p>首先考虑各种需求该如何实现。</p><ol><li><p>让番剧也可以加入稍后再看。</p><p>首先是可行性。B 站的稍后再看 API 需要 <code>aid</code> （即视频 ID）作为参数，而番剧的单集 ID 是 <code>epid</code>。只需要通过番剧播放页就可以获取 <code>epid</code> 对应的 <code>aid</code>，再调用 API 就可以将番剧加入稍后再看。</p><p>然后是如何实现。目前常规视频在封面图右下角都会有一个稍后再看按钮，点击就可以添加或删除稍后再看，然后番剧的封面却没有。因此实现番剧加入稍后再看非常简单，只需要给番剧的封面也添加一个稍后再看按钮就可以了。</p></li><li><p>稍后再看按钮的初始状态。</p><p>在之前提到的初级版本里，我解决这个问题的方法非常粗暴：首先通过 API 确定每个视频是否已经加入了稍后再看，对于已经加入稍后再看的视频，给它的按钮添加一个 <code>class</code> 改变样式。</p><p>这样的好处是非常简单粗暴，几行就可以写完所有逻辑。但是坏处也显而易见，按钮仅仅是样式改变了，功能却没有，导致点击一个已勾选的按钮结果却又是将视频加入稍后再看，而不是勾选按钮应该做的”将视频移出稍后再看“。简单的来说就是按钮功能和样式的不统一。</p><p><strong>要实现按钮功能和样式的统一</strong>，只能抛弃原有的按钮，自己从头开始为每个视频添加稍后再看按钮。这样按钮的样式、功能都可以自己控制，唯一的缺点就是需要一定的工作量。</p></li><li><p>可以在稍后再看播放番剧。</p><p>这个是最让我头疼的地方就是如何在稍后再看中播放番剧。最后我发现 Hack B 站的视频播放器使之能播放番剧太麻烦了，不如我自己实现一个稍后再看的播放逻辑。</p><p>原本的播放逻辑是 B 站在一个专为稍后再看编写的单页面应用中，逐个播放视频，当遇到番剧时就无法解析并弹窗。为了简化开发，我设定的新逻辑是，点击稍后再看的视频直接跳转到常规视频播放页面，并在页面左边添加一个汉堡菜单，可以看到并跳转到其他稍后再看。</p></li></ol><h2 id="3-2-监听页面变化"><a href="#3-2-监听页面变化" class="headerlink" title="3.2. 监听页面变化"></a>3.2. 监听页面变化</h2><p>上面提到，我们需要替换、添加按钮，但这会遇到几个问题：</p><ul><li>由于油猴脚本可能在任何时候插入页面，此时页面的状态不确定</li><li>页面可能在任何时候更新，比如加载中的页面或者用户点击导致页面变化</li></ul><hr><p>最理想的实现是，监听页面的变化。这里提出一个需求，我需要寻找页面中所有的旧按钮，替换成新的自定义的按钮。利用 HTML 提供的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver" target="_blank" rel="noopener">MutationObserver</a> API，我们可以订阅某个根节点下的所有变化，我们只需要在变化的节点下寻找有没有旧按钮就行了。</p><hr><p>但是现在出现了另一个需求：添加按钮。</p><p>添加按钮的逻辑是，找到一个父元素，这个父元素原本应该有稍后再看按钮，而现在却没有，那么我们就向父元素里添加自定义的按钮。也就是说我们搜索的检查点有两个，父元素和是否有子元素，只有”找到父元素“和”按钮子元素不存在“同时满足时，才添加自定义按钮。</p><p>让我们回想刚刚提到的方法，首先 MutationObserver 会提供一个有更改的节点，如果目标父元素和子元素都位于这个节点下，那么没有问题，我们可以很轻松的搜索到。但如果 MutationObserver 回调的节点位于父元素和子元素之间，搜索就会变得略微复杂，因为我们需要通知向两个方向搜索。</p><hr><p>最终妥协了上述两种情况，使用的解决方案是，使用 MutationObserver 监听这个 <code>document.body</code> 的变化。在每次变化发生之后，遍历整个文档寻找目标节点。</p><p>这样的做法好处是，遍历的逻辑非常简单，直接使用 JQuery 就可以做到。坏处是更加耗时，因为每次整个文档的任意一处发生变化时，哪怕变化的地方与我们的目标毫无关系，都需要遍历整个文档树，而且通常整个 HTML 文档会在短时间内频繁地更新。为了解决性能问题，使用 Lodash 的 <code>debounce</code> 函数对回调去抖动，这样短时间内的频繁更新只会触发一次搜索。</p><p>大致代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> MutationObserver((mutationList) = &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> mutation <span class="keyword">of</span> mutationList)&#123;</span><br><span class="line">        <span class="comment">// 只关心添加节点的变化</span></span><br><span class="line">        <span class="keyword">if</span> (mutation.addedNodes.length) &#123;</span><br><span class="line">            <span class="comment">// 200 毫秒内的频繁调用只会触发一次</span></span><br><span class="line">            _.debounce(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                $(<span class="string">'...'</span>).each(<span class="function">(<span class="params">index, ele</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="comment">// 找到的目标</span></span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;, <span class="number">200</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).observe(<span class="built_in">document</span>.body, &#123;</span><br><span class="line">    childList: <span class="literal">true</span>,</span><br><span class="line">    subtree: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="3-3-异步更新状态"><a href="#3-3-异步更新状态" class="headerlink" title="3.3. 异步更新状态"></a>3.3. 异步更新状态</h2><p>在开发中还遇到一个小情景：现在所有的稍后再看按钮都成功替换成了自定义的按钮，然而因为稍后再看列表是异步获取的，没办法同步地给这些按钮设置是否勾选的状态。</p><p>那么如何异步地给按钮们更新状态呢？</p><p>一个最简单粗暴的思路就是：按钮默认都是不勾选的状态。此时去获取稍后再看列表，待数据返回后，再从页面中找回所有的按钮，依次给他们分配状态。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> oldButton <span class="keyword">of</span> oldButtons) &#123;</span><br><span class="line">    <span class="keyword">const</span> button = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">    button.aid = <span class="string">'...'</span>;</span><br><span class="line">    <span class="comment">// 默认不勾选</span></span><br><span class="line">    button.checked = <span class="literal">false</span>;</span><br><span class="line">    button.className = <span class="string">'watch-later-plus-button'</span>;</span><br><span class="line">    oldButton.replaceWith(button);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> watchlaterList = <span class="keyword">await</span> getWatchlaterList();</span><br><span class="line">$(<span class="string">'.watch-later-plus-button'</span>)</span><br><span class="line">    .filter(<span class="string">'...'</span>)<span class="comment">// 根据 watchlaterList 过滤出需要勾选的按钮</span></span><br><span class="line">    .each(<span class="function">(<span class="params">_, ele</span>) =&gt;</span> ele.checked = <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>上面的想法可以通过保存按钮引用的方式减少一次遍历：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newButtons = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> oldButton <span class="keyword">of</span> oldButtons) &#123;</span><br><span class="line">    <span class="keyword">const</span> button = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">    button.aid = <span class="string">'...'</span>;</span><br><span class="line">    <span class="comment">// 默认不勾选</span></span><br><span class="line">    button.checked = <span class="literal">false</span>;</span><br><span class="line">    newButtons.push(buttons);</span><br><span class="line">    oldButton.replaceWith(button);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> watchlaterList = <span class="keyword">await</span> getWatchlaterList();</span><br><span class="line">buttons.filter(<span class="string">'...'</span>)<span class="comment">// 根据 watchlaterList 过滤出需要勾选的按钮</span></span><br><span class="line">       .forEach(<span class="function">(<span class="params">ele</span>) =&gt;</span> ele.checked = <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>上面两个方法本质是一样的，在创建按钮之后单独维护了一系列用于更新状态的语句。</p><p>我们可以利用闭包以及 Promise 的特性，写出这样的方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> watchLaterList = <span class="function">(<span class="params">(</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> promise;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!promise) &#123;</span><br><span class="line">            promise = getWatchLaterList();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> oldButton <span class="keyword">of</span> oldButtons) &#123;</span><br><span class="line">    <span class="keyword">const</span> button = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">    button.aid = <span class="string">'...'</span>;</span><br><span class="line">    watchLaterList().then(<span class="function"><span class="params">list</span> =&gt;</span> &#123;</span><br><span class="line">        button.checked = list.includes(button.aid);</span><br><span class="line">    &#125;);</span><br><span class="line">    buttons.push(buttons);</span><br><span class="line">    oldButton.replaceWith(button);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样更新状态的逻辑就不需要单独维护了。</p><h1 id="4-现状和吐槽"><a href="#4-现状和吐槽" class="headerlink" title="4. 现状和吐槽"></a>4. 现状和吐槽</h1><p>使用脚本之后，上面提到的 B站稍后再看的问题都得到了解决，特别是番剧也支持稍后再看之后，使用体验非常棒。</p><p><img src="/assets/image-20190125224055885.png" alt="image-20190125224055885"></p><p>不要嫌弃我的 UI，又不是不能用。之后 B 站再改 UI 或 API 的时候再更新吧。</p><p>吐槽一下 B 站的前端，写个新版本的 UI 还只有播放界面才有，还是常规视频的播放界面有新 UI 而番剧的播放界面没有；其他地方都是普通的多页应用，但是到了稍后再看和个人空间确实单页面应用；就一个稍后再看的按钮的逻辑，在首页、动态悬浮窗、动态首页、空间页面的实现居然都是不一样的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;B 站的稍后再看功能明显是一个半成品，有许多不完善的地方，其中最致命的就是无法加入和播放番剧。最近我终于忍受不了它的诸多问题，着手开发了一个油猴脚本 Bilibili Watchlater Plus，对稍后再看功能进行了一番改造。开源地址：&lt;a href=&quot;https://github.com/Andiedie/bilibili-watchlater-plus&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;bilibili-watchlater-plus&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>常用的 Badge</title>
    <link href="http://blog.andiedie.cn/posts/5d4d/"/>
    <id>http://blog.andiedie.cn/posts/5d4d/</id>
    <published>2019-01-24T07:26:15.000Z</published>
    <updated>2019-05-10T13:08:07.547Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在开源项目的 Readme 中添加 Badge 已经成为了一种浪漫。这里列举一些个人常用的 Badge，供日后参考。</p><a id="more"></a><p>主要使用的是 <a href="https://shields.io" target="_blank" rel="noopener">shields.io</a> 提供的服务，通过它获得的 Badge 可以定制样式、颜色、图标等。</p><h1 id="1-仓库状态"><a href="#1-仓库状态" class="headerlink" title="1. 仓库状态"></a>1. 仓库状态</h1><ul><li><p><a href="https://travis-ci.org/" target="_blank" rel="noopener">Travis CI</a></p><p><img src="https://img.shields.io/travis/kevast/kevast.js.svg?style=flat-square" alt=""></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](https://img.shields.io/travis/$&#123;USER&#125;/$&#123;REPO&#125;.svg?style=flat-square)</span><br></pre></td></tr></table></figure></li><li><p><a href="https://coveralls.io/" target="_blank" rel="noopener">Coveralls</a></p><p><img src="https://img.shields.io/coveralls/github/kevast/kevast.js.svg?style=flat-square" alt=""></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](https://img.shields.io/coveralls/$&#123;VSC_TYPE&#125;/$&#123;USER&#125;/$&#123;REPO&#125;.svg?style=flat-square)</span><br></pre></td></tr></table></figure></li><li><p><a href="https://codeclimate.com/" target="_blank" rel="noopener">Code Climate</a> maintainability</p><p><img src="https://img.shields.io/codeclimate/maintainability/kevast/kevast.js.svg?style=flat-square" alt=""></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](https://img.shields.io/codeclimate/maintainability/$&#123;USER&#125;/$&#123;REPO&#125;.svg?style=flat-square)</span><br></pre></td></tr></table></figure></li></ul><h1 id="2-GitHub"><a href="#2-GitHub" class="headerlink" title="2. GitHub"></a>2. GitHub</h1><ul><li><p>GitHub issues</p><p><img src="https://img.shields.io/github/issues-raw/kevast/kevast.js.svg?style=flat-square" alt=""></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](https://img.shields.io/github/issues-raw/$&#123;USER&#125;/$&#123;REPO&#125;.svg?style=flat-square)</span><br></pre></td></tr></table></figure></li><li><p>GitHub license</p><p><img src="https://img.shields.io/github/license/kevast/kevast.js.svg?style=flat-square" alt=""></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](https://img.shields.io/github/license/$&#123;USER&#125;/$&#123;REPO&#125;.svg?style=flat-square)</span><br></pre></td></tr></table></figure></li><li><p>GitHub release</p><p><img src="https://img.shields.io/github/release/andiedie/sync-my-cookie.svg?style=flat-square" alt=""></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](https://img.shields.io/github/$&#123;USER&#125;/$&#123;REPO&#125;.svg?style=flat-square)</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>Contributions welcome</p><p><img src="https://img.shields.io/badge/contributions-welcome-brightgreen.svg?style=flat-square" alt=""></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](https://img.shields.io/badge/contributions-welcome-brightgreen.svg?style=flat-square)</span><br></pre></td></tr></table></figure></li></ul><h1 id="3-Npm"><a href="#3-Npm" class="headerlink" title="3. Npm"></a>3. Npm</h1><ul><li><p>Npm package vulnerabilities</p><p><img src="https://img.shields.io/snyk/vulnerabilities/npm/kevast.svg?style=flat-square" alt=""></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](https://img.shields.io/snyk/vulnerabilities/npm/$&#123;PACKAGE&#125;.svg?style=flat-square)</span><br></pre></td></tr></table></figure></li><li><p>Dependencies</p><p><img src="https://img.shields.io/david/kevast/kevast.js.svg?style=flat-square" alt=""></p><p><img src="https://img.shields.io/david/dev/kevast/kevast.js.svg?style=flat-square" alt=""></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">![](https://img.shields.io/david/$&#123;USER&#125;/$&#123;REPO&#125;.svg?style=flat-square)</span><br><span class="line">![](https://img.shields.io/david/dev/$&#123;USER&#125;/$&#123;REPO&#125;.svg?style=flat-square)</span><br></pre></td></tr></table></figure></li><li><p>Npm download</p><p><img src="https://img.shields.io/npm/dt/kevast.svg" alt=""></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](https://img.shields.io/npm/dt/$&#123;PACKAGE&#125;.svg)</span><br></pre></td></tr></table></figure></li><li><p>Npm package version</p><p><img src="https://img.shields.io/npm/v/kevast.svg?style=flat-square" alt=""></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](https://img.shields.io/npm/v/$&#123;PACKAGE&#125;.svg?style=flat-square)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在开源项目的 Readme 中添加 Badge 已经成为了一种浪漫。这里列举一些个人常用的 Badge，供日后参考。&lt;/p&gt;
    
    </summary>
    
      <category term="Development" scheme="http://blog.andiedie.cn/categories/Development/"/>
    
    
  </entry>
  
  <entry>
    <title>115 账号共享之路</title>
    <link href="http://blog.andiedie.cn/posts/dbf/"/>
    <id>http://blog.andiedie.cn/posts/dbf/</id>
    <published>2019-01-23T12:20:53.000Z</published>
    <updated>2019-05-10T13:08:07.540Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>115 的离线下载功能确实强悍，但是 500 元一年的会员价格也不便宜。于是我就与三个朋友一起合买了一年会员，准备四人共享使用。但是 115 的单点登录却给共享带来了很多限制，于是我们探索了诸多共享方案，期间历程就便成了这篇博文。</p><a id="more"></a><h1 id="1-115-的限制"><a href="#1-115-的限制" class="headerlink" title="1. 115 的限制"></a>1. 115 的限制</h1><ul><li><p>单点登录</p><p>115 在所有客户端，包括网页端，PC 端（本质就是网页端）和手机端都实行单点登录。这就意味着，只要有任何一个客户端通过账号密码登录成功，之前的所有登录都会失效，无论是什么端。</p></li><li><p>115 浏览器</p><p>在网页端只能通过手机端扫码才能登陆，在 115 浏览器上可以通过账号密码登录，但是初次登录依然需要手机接收验证码。不过整体来说就 115 服务的使用上，115 浏览器还是要优于 Chrome：在 115 浏览器上下载 115 资源可以支持多线程下载和断点续传；且在 115 浏览器上打开磁力链接可以直接启动 115 离线下载。但是 115 浏览器 Chromium 版本还停留在 54，且标签页开的一多就卡顿，所以也只能当做 115 客户端用。</p></li></ul><h1 id="2-瞎搞阶段"><a href="#2-瞎搞阶段" class="headerlink" title="2. 瞎搞阶段"></a>2. 瞎搞阶段</h1><p>一开始我们四人并没有想出如何破解 115 的单点登录限制。因此临时的共享方案是“二级离线下载”。具体如下：</p><ul><li>我们在校内有一台公用电脑，24 小时开机并保持 115 登录状态。</li><li>任何人有下载需求时，就通过远程桌面连接公用电脑，将资源下载到公用电脑上。</li><li>公用电脑下载结束后，利用校园的百兆内网，通过 FTP 传回自己的电脑。</li></ul><p>这当然有诸多限制：</p><ul><li>在公网环境下，无论是远程桌面控制内网的公用电脑，还是 FTP 从内网公用电脑取下载资源都比较困难。</li><li>远程桌面是抢占式的，也就是说一个人在使用过程中会被另一个登录的人挤下去。</li><li>“二级离线下载”永远还是要多一步，非常麻烦。</li></ul><p>为了解决上述问题，我们也付出了一些努力：</p><ul><li>通过内网穿透，在公网也能轻松访问公用电脑。但是我的服务器水管太小，用 FTP 取回资源的速度太慢。</li><li>为了解决远程桌面抢占式的问题，我们在公用电脑上搭建了一个状态服务器，可以随时显示当前公用电脑有没有被使用。接着制作了一个远程桌面的脚本，先取公用电脑状态，只有空闲时才会继续启用远程桌面。</li></ul><p>虽然通过上面两个 workaround 解决了部分问题，但是水管太小，操作麻烦的本质问题还是没有得到解决，再继续下去只是在点错的技能树继续错下去而已。</p><h1 id="3-利用-Cookies-共享账号"><a href="#3-利用-Cookies-共享账号" class="headerlink" title="3. 利用 Cookies 共享账号"></a>3. 利用 Cookies 共享账号</h1><p>其实很多人应该看到这里应该会嘲笑我，因为用 Cookies 来共享账号应该是非常容易想到的事情。</p><p>确实，当时我的第一个想法也是利用 Cookies，但是由于学艺不精，我测试时是通过 <code>document.cookie</code> 提取 Cookies。这当然会失败，当时愚蠢的我就这么放弃了 Cookies 的方法，而走了上面的歪路。</p><p>具体为何失败，以及转机是什么，之后再聊。</p><h2 id="3-1-基本原理"><a href="#3-1-基本原理" class="headerlink" title="3.1. 基本原理"></a>3.1. 基本原理</h2><p>115 的用来记录用户登录状态的 Cookies 是 Session 级别的。也就是说，一旦浏览器被关闭，这些 Cookies 就会被删除。</p><p>重点在于删除而不是失效，也就是说说被删除的 Cookies 是有效的。于是我们只需要在成功登陆之后，将 Cookies 保存下来，并在需要共享的浏览器上套用这些 Cookies 就好了。并且 Session 级别的 Cookies 是没有过期时间的，所以理论上只要服务器不做相关验证，我们可以永久维持登录状态。</p><h2 id="3-2-转机"><a href="#3-2-转机" class="headerlink" title="3.2. 转机"></a>3.2. 转机</h2><p>上面提到的转机就是这个 Chrome 插件：<a href="http://www.editthiscookie.com/" target="_blank" rel="noopener">EditThisCookie</a>。</p><p>这个插件主要就是为 <a href="https://developer.chrome.com/extensions/cookies" target="_blank" rel="noopener">Chrome Extension Cookies API</a> 提供了 GUI 界面，从而使开发者可以很方便地通过 Chrome 扩展的能力编辑 Cookies。</p><p>稍加尝试就会发现，通过 EditThisCookie 提取的 Cookies，或者说通过 Chrome Extension Cookies API 提取的 Cookies 和 <code>document.cookie</code> 提取的 Cookies 完全不同。</p><p>我们以 115 为例：</p><ul><li><p>通过 <code>document.cookie</code> 提取的 Cookies：</p><p><img src="/assets/image-20190123225803208.png" alt="cookies from document.cookie"></p></li><li><p>通过 EditThisCookie 提取的 Cookies：</p><p><img src="/assets/image-20190123225721209.png" alt="Cookies from EditThisCookie"></p></li></ul><p>这里实际上保存登录状态的三个 Cookies：<code>UID</code>、<code>CID</code> 和 <code>SEID</code> 在前者都找不到，反而一些无关紧要的 Cookies 都能获取到。这是因为在一些关键的 Cookies 上，通常会多设置一个 flag 叫 <code>HttpOnly</code>。</p><p><img src="/assets/image-20190123230512370.png" alt="HttpOnly flag"></p><p>根据 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies#Cookie%E7%9A%84Secure_%E5%92%8CHttpOnly_%E6%A0%87%E8%AE%B0" target="_blank" rel="noopener">MDN 的解释</a>，为避免跨域脚本 (<a href="https://developer.mozilla.org/en-US/docs/Glossary/XSS" target="_blank" rel="noopener">XSS</a>) 攻击，通过 JavaScript 的 <code>document.cookie</code> 无法访问带有 <code>HttpOnly</code> 标记的 Cookies，它们只会在 HTTP 请求是被发送给服务端。</p><p>因此可以很清楚的看到，在 <code>115.com</code> 域下共有 7 个 Cookies，其中 4 个被设置了 <code>HttpOnly</code>，因此 <code>document.cookie</code> 只能获取到另外 3 个；而 Chrome Extension Cookie API 则可以获取所有 Cookies。</p><h2 id="3-3-SyncMyCookie-诞生"><a href="#3-3-SyncMyCookie-诞生" class="headerlink" title="3.3. SyncMyCookie 诞生"></a>3.3. SyncMyCookie 诞生</h2><p>虽然使用 EditThisCookie 已经能够轻松的导入和导出 Cookies，实现分享账号。但是每次更新登录状态时都需将 JSON 格式的 Cookies 信息分享给别人，且对于 Session 级别的 Cookies，每次打开浏览器都必须重新导入一次，不够方便。</p><p>为了解决上面的问题，我编写了 Chrome 插件 <a href="https://chrome.google.com/webstore/detail/laapobniolmbhnkldepjnebendehhmmf" target="_blank" rel="noopener">SyncMyCookie</a>。</p><p><img src="/assets/image-20190123231220452.png" alt="image-20190123231220452"></p><p>它的工作原理也非常简单，使用 Chrome Extension Cookies API 从浏览器提取指定域名下的所有 Cookies，并将这些 Cookies 经过 <code>AES-128-CBC</code> 加密后保存在 GitHub Gist 中。这里 GitHub Gist 只是充当一个存储作用。</p><p>在此基础上，SyncMyCookie 提供了两个自动化功能：</p><ul><li>Auto Merge：可以在浏览器启动时自动将指定的 Cookies 合并进浏览器，特别适合 Session 级别的 Cookies。</li><li>Auto Push：在指定的 Cookies 发生变化时，自动推送保存。</li></ul><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><p>使用 SyncMyCookie 共享 115 账号基本做到了我能想象地最好体验：</p><ul><li>我在自己的 115 浏览器安装插件并设置自动推送 115 的 Cookies</li><li>共享账号的朋友在 115 浏览器安装插件并设置自动合并 115 的 Cookies</li><li>每个人都可以满速下载，随意使用任何功能。</li></ul><p>SyncMyCookie 也可以随意同步任何在浏览器提供服务，并使用 Cookies 记录登录状态的应用。简单测试了一下 Bilibili、爱奇艺、优酷、腾讯等视频网站都是可以使用的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;115 的离线下载功能确实强悍，但是 500 元一年的会员价格也不便宜。于是我就与三个朋友一起合买了一年会员，准备四人共享使用。但是 115 的单点登录却给共享带来了很多限制，于是我们探索了诸多共享方案，期间历程就便成了这篇博文。&lt;/p&gt;
    
    </summary>
    
      <category term="Trivia" scheme="http://blog.andiedie.cn/categories/Trivia/"/>
    
    
  </entry>
  
  <entry>
    <title>Mocha 复用测试用例</title>
    <link href="http://blog.andiedie.cn/posts/cc67/"/>
    <id>http://blog.andiedie.cn/posts/cc67/</id>
    <published>2018-12-13T10:57:32.000Z</published>
    <updated>2019-05-10T13:08:07.542Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在使用 Mocha 进行单元测试时，经常会有复用测试用例的需求。例如定义了一组测试用例后，希望在多种环境下都使用这组用例进行测试。</p><a id="more"></a><h1 id="1-测试环境"><a href="#1-测试环境" class="headerlink" title="1. 测试环境"></a>1. 测试环境</h1><p>首先简单地搭建一个测试环境。</p><p>创建项目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir mocha-reuse</span><br><span class="line"><span class="built_in">cd</span> mocha-reuse</span><br><span class="line">yarn init -y</span><br><span class="line">yarn add -D mocha</span><br></pre></td></tr></table></figure><p>项目目录结构如下：</p><ul><li><code>index.js</code></li><li><code>test</code><ul><li><code>index.test.js</code></li></ul></li></ul><p>其中 <code>index.js</code> 内容如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, age) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> name === <span class="string">'string'</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name <span class="keyword">instanceof</span> Buffer) &#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name.toString();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">TypeError</span>(<span class="string">'Name can only be string or buffer'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> age === <span class="string">'number'</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> age === <span class="string">'string'</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.age = <span class="built_in">Number</span>(age);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">TypeError</span>(<span class="string">'Age can only be number or string'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>: <span class="subst">$&#123;<span class="keyword">this</span>.age&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑非常简单，<code>Human</code> 类构造时需要两个参数，<code>name</code> 支持 <code>string</code> 和 <code>Buffer</code>；<code>age</code> 支持 <code>number</code> 和 <code>string</code>。</p><p>测试内容是，构造一个 <code>Human</code> 实例后测试 <code>name</code>、<code>age</code> 和 <code>toString()</code> 是否正确。</p><h1 id="2-无复用版本"><a href="#2-无复用版本" class="headerlink" title="2. 无复用版本"></a>2. 无复用版本</h1><p>为了提高测试覆盖率，必须使用每一种可能的参数组合实例化 <code>Human</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test/index.test.js</span></span><br><span class="line"><span class="keyword">const</span> assert = <span class="built_in">require</span>(<span class="string">'assert'</span>);</span><br><span class="line"><span class="keyword">const</span> Human = <span class="built_in">require</span>(<span class="string">'../index'</span>);</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'Test with string name and number age'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> human;</span><br><span class="line">  before(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    human = <span class="keyword">new</span> Human(<span class="string">'A'</span>, <span class="number">1</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  it(<span class="string">'Check name'</span>, () =&gt; &#123;</span><br><span class="line">    assert(human.name === <span class="string">'A'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  it(<span class="string">'Check age'</span>, () =&gt; &#123;</span><br><span class="line">    assert(human.age === <span class="number">1</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  it(<span class="string">'Check toString'</span>, () =&gt; &#123;</span><br><span class="line">    assert(human.toString() === <span class="string">'A: 1'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'Test with buffer name and number age'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> human;</span><br><span class="line">  before(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    human = <span class="keyword">new</span> Human(Buffer.from(<span class="string">'A'</span>), <span class="number">1</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  it(<span class="string">'Check name'</span>, () =&gt; &#123;</span><br><span class="line">    assert(human.name === <span class="string">'A'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  it(<span class="string">'Check age'</span>, () =&gt; &#123;</span><br><span class="line">    assert(human.age === <span class="number">1</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  it(<span class="string">'Check toString'</span>, () =&gt; &#123;</span><br><span class="line">    assert(human.toString() === <span class="string">'A: 1'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'Test with string name and string age'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> human;</span><br><span class="line">  before(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    human = <span class="keyword">new</span> Human(<span class="string">'A'</span>, <span class="string">'1'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  it(<span class="string">'Check name'</span>, () =&gt; &#123;</span><br><span class="line">    assert(human.name === <span class="string">'A'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  it(<span class="string">'Check age'</span>, () =&gt; &#123;</span><br><span class="line">    assert(human.age === <span class="number">1</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  it(<span class="string">'Check toString'</span>, () =&gt; &#123;</span><br><span class="line">    assert(human.toString() === <span class="string">'A: 1'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'Test with buffer name and string age'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> human;</span><br><span class="line">  before(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    human = <span class="keyword">new</span> Human(Buffer.from(<span class="string">'A'</span>), <span class="string">'1'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  it(<span class="string">'Check name'</span>, () =&gt; &#123;</span><br><span class="line">    assert(human.name === <span class="string">'A'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  it(<span class="string">'Check age'</span>, () =&gt; &#123;</span><br><span class="line">    assert(human.age === <span class="number">1</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  it(<span class="string">'Check toString'</span>, () =&gt; &#123;</span><br><span class="line">    assert(human.toString() === <span class="string">'A: 1'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可以看到，除了初始化不同之外，所有的测试样例都是一样的，因此我们必须想办法复用测试用例</p><h1 id="3-复用测试用例"><a href="#3-复用测试用例" class="headerlink" title="3. 复用测试用例"></a>3. 复用测试用例</h1><p> 在 <code>test</code> 目录下创建新的文件 <code>share.js</code>，将复用的用例放在里面：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> assert = <span class="built_in">require</span>(<span class="string">'assert'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  it(<span class="string">'Check name'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    assert(<span class="keyword">this</span>.human.name === <span class="string">'A'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  it(<span class="string">'Check age'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    assert(<span class="keyword">this</span>.human.age === <span class="number">1</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  it(<span class="string">'Check toString'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    assert(<span class="keyword">this</span>.human.toString() === <span class="string">'A: 1'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此时目录结构变为：</p><ul><li><code>index.js</code></li><li><code>test</code><ul><li><code>index.test.js</code></li><li><code>share.js</code></li></ul></li></ul><p><code>index.test.js</code> 变为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Human = <span class="built_in">require</span>(<span class="string">'../index'</span>);</span><br><span class="line"><span class="keyword">const</span> check = <span class="built_in">require</span>(<span class="string">'./share'</span>);</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'Test with string name and number age'</span>, () =&gt; &#123;</span><br><span class="line">  before(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.human = <span class="keyword">new</span> Human(<span class="string">'A'</span>, <span class="number">1</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  check();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'Test with buffer name and number age'</span>, () =&gt; &#123;</span><br><span class="line">  before(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.human = <span class="keyword">new</span> Human(Buffer.from(<span class="string">'A'</span>), <span class="number">1</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  check();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'Test with string name and string age'</span>, () =&gt; &#123;</span><br><span class="line">  before(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.human = <span class="keyword">new</span> Human(<span class="string">'A'</span>, <span class="string">'1'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  check();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'Test with buffer name and string age'</span>, () =&gt; &#123;</span><br><span class="line">  before(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.human = <span class="keyword">new</span> Human(Buffer.from(<span class="string">'A'</span>), <span class="string">'1'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  check();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>要注意的是，这里在所有涉及 <code>this</code> 的函数上，不要使用箭头函数。</p><h1 id="4-参考"><a href="#4-参考" class="headerlink" title="4. 参考"></a>4. 参考</h1><p><a href="https://github.com/mochajs/mocha/wiki/Shared-Behaviours" target="_blank" rel="noopener">Shared Behaviours</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在使用 Mocha 进行单元测试时，经常会有复用测试用例的需求。例如定义了一组测试用例后，希望在多种环境下都使用这组用例进行测试。&lt;/p&gt;
    
    </summary>
    
      <category term="Tutorial" scheme="http://blog.andiedie.cn/categories/Tutorial/"/>
    
    
  </entry>
  
  <entry>
    <title>TypeScript 初入坑</title>
    <link href="http://blog.andiedie.cn/posts/7625/"/>
    <id>http://blog.andiedie.cn/posts/7625/</id>
    <published>2018-12-10T12:17:37.000Z</published>
    <updated>2019-01-24T07:00:37.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文主要介绍我入坑 TypeScript 以后总结的一些相关配置，包括：</p><ul><li>TypeScript 安装、配置与调试</li><li>TSLint 配置</li><li>TypeScript 编写与发布 npm 包</li><li>TypeScript 与 webpack、babel</li><li>TypeScript 测试与覆盖率</li></ul><a id="more"></a><h1 id="1-TypeScript-基本配置"><a href="#1-TypeScript-基本配置" class="headerlink" title="1. TypeScript 基本配置"></a>1. TypeScript 基本配置</h1><h2 id="1-1-安装-TypeScript"><a href="#1-1-安装-TypeScript" class="headerlink" title="1.1. 安装 TypeScript"></a>1.1. 安装 TypeScript</h2><p>全局安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn global add typescript</span><br></pre></td></tr></table></figure><p>不过我个人还是更加推荐在每个 TypeScript 项目下都安装一个开发依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add -D typescript</span><br></pre></td></tr></table></figure><p>如果是在 Node.js 环境下编写，还推荐安装相应的类型声明：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add -D @types/node</span><br></pre></td></tr></table></figure><p>安装完后可以使用 <code>tsc</code> 对 TypeScript 文件进行编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全局安装</span></span><br><span class="line">tsc test.ts</span><br><span class="line"><span class="comment"># 项目安装</span></span><br><span class="line">npx tsc test.ts</span><br></pre></td></tr></table></figure><p>使用 <code>tsc --help</code> 可以查看到编译选项。</p><h2 id="1-2-配置-tsconfig-json"><a href="#1-2-配置-tsconfig-json" class="headerlink" title="1.2. 配置 tsconfig.json"></a>1.2. 配置 tsconfig.json</h2><p><code>tsc</code> 提供的编译选项十分丰富，我们也经常需要在项目编译时指定一些参数，然后每次编译时都手动输入这些参数非常麻烦，我们可以在项目根目录创建 <code>tsconfig.json</code> 文件作为配置文件，运行 <code>tsc</code> 且不指定输入文件时，会默认应用文件中的配置。</p><p>一个简单的 <code>tsconfig.json</code> 如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="attr">"outDir"</span>: <span class="string">"./dist"</span>,</span><br><span class="line">    <span class="attr">"noImplicitAny"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"module"</span>: <span class="string">"CommonJS"</span>,</span><br><span class="line">    <span class="attr">"declaration"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"target"</span>: <span class="string">"ES2015"</span>,</span><br><span class="line">    <span class="attr">"strict"</span>: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"include"</span>: [<span class="string">"src"</span>],</span><br><span class="line">  <span class="attr">"exclude"</span>: [<span class="string">"node_modules"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>outDir</code> 指定了目标文件输出位置</li><li><code>noImplicitAny</code> 检查在源代码中不能有隐式声明的 <code>Any</code> 类型</li><li><code>module</code> 指定了模块规范</li><li><code>declaration</code> 输出目标文件时同时输出类型声明文件</li><li><code>target</code> 指定 JavaScript 的版本</li><li><code>strict</code> 严格模式</li><li><code>include</code> 和 <code>exclude</code> 指定输入和排除目录</li></ul><p>详细配置可见 <a href="https://www.typescriptlang.org/docs/handbook/tsconfig-json.html" target="_blank" rel="noopener">tsconfig.json</a> 。</p><p>配置完后直接运行 <code>tsc</code> 即可。</p><h2 id="1-3-调试-TypeScript"><a href="#1-3-调试-TypeScript" class="headerlink" title="1.3. 调试 TypeScript"></a>1.3. 调试 TypeScript</h2><p>这里演示如何在 VS Code 中调试 TypeScript。</p><p>调试的配置文件位于 <code>.vscode/launch.json</code>，建议将整个 <code>.vscode</code> 文件夹加入 <code>.gitignore</code>中。</p><h3 id="调试编译后的-JavaScript"><a href="#调试编译后的-JavaScript" class="headerlink" title="调试编译后的 JavaScript"></a>调试编译后的 JavaScript</h3><p>一种最简单的方法是调试编译后的 JavaScript：</p><p>在 <code>.vscode/launch.json</code> 中加入配置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"0.2.0"</span>,</span><br><span class="line">  <span class="attr">"configurations"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"node"</span>,</span><br><span class="line">      <span class="attr">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"Debug JavaScript"</span>,</span><br><span class="line">      <span class="attr">"program"</span>: <span class="string">"$&#123;workspaceRoot&#125;/dist/index.js"</span>,</span><br><span class="line">      <span class="attr">"args"</span>: [],</span><br><span class="line">      <span class="attr">"protocol"</span>: <span class="string">"inspector"</span>,</span><br><span class="line">      <span class="attr">"cwd"</span>: <span class="string">"$&#123;workspaceRoot&#125;"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="直接调试-TypeScript"><a href="#直接调试-TypeScript" class="headerlink" title="直接调试 TypeScript"></a>直接调试 TypeScript</h3><p>直接调试 JavaScript 的好处是配置简单、但每次都需要显式地编译非常麻烦。这里使用 <code>ts-node</code> 作为运行环境，就可以直接调试 TypeScript 了。</p><p>安装 <code>ts-node</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add -D ts-node</span><br></pre></td></tr></table></figure><p>在 <code>tsconfig.json</code> 中开启 <code>sourceMap</code>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="attr">"outDir"</span>: <span class="string">"./dist"</span>,</span><br><span class="line">    <span class="attr">"noImplicitAny"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"module"</span>: <span class="string">"CommonJS"</span>,</span><br><span class="line">    <span class="attr">"declaration"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"target"</span>: <span class="string">"ES2015"</span>,</span><br><span class="line">    <span class="attr">"strict"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"sourceMap"</span>: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"include"</span>: [<span class="string">"src"</span>],</span><br><span class="line">  <span class="attr">"exclude"</span>: [<span class="string">"node_modules"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置 <code>.vscode/launch.json</code>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"0.2.0"</span>,</span><br><span class="line">  <span class="attr">"configurations"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"node"</span>,</span><br><span class="line">      <span class="attr">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"Debug TypeScript"</span>,</span><br><span class="line">      <span class="attr">"args"</span>: [<span class="string">"$&#123;relativeFile&#125;"</span>],</span><br><span class="line">      <span class="attr">"runtimeArgs"</span>: [<span class="string">"--nolazy"</span>, <span class="string">"-r"</span>, <span class="string">"ts-node/register"</span>],</span><br><span class="line">      <span class="attr">"sourceMaps"</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">"protocol"</span>: <span class="string">"inspector"</span>,</span><br><span class="line">      <span class="attr">"cwd"</span>: <span class="string">"$&#123;workspaceRoot&#125;"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-TSLint"><a href="#2-TSLint" class="headerlink" title="2. TSLint"></a>2. TSLint</h1><h2 id="2-1-基本配置"><a href="#2-1-基本配置" class="headerlink" title="2.1. 基本配置"></a>2.1. 基本配置</h2><p>编写 JavaScript 时一般会使用 ESLint 对代码进行检查。同样的， 在 TypeScript 中我们使用 TSLint。</p><p>首先需要安装依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add -D tslint</span><br></pre></td></tr></table></figure><p>接着进行配置，在根目录创建 <code>tslint.json</code> 文件，一个典型的例子：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"extends"</span>: [<span class="string">"tslint:recommended"</span>],</span><br><span class="line">  <span class="attr">"rules"</span>: &#123;</span><br><span class="line">      <span class="attr">"quotemark"</span>: [<span class="literal">true</span>, <span class="string">"single"</span>],</span><br><span class="line">      <span class="attr">"no-empty"</span>: [<span class="literal">true</span>, <span class="string">"allow-empty-functions"</span>],</span><br><span class="line">      <span class="attr">"trailing-comma"</span>: [<span class="literal">true</span>, &#123;<span class="attr">"multiline"</span>: <span class="string">"always"</span>, <span class="attr">"singleline"</span>: <span class="string">"never"</span>&#125;],</span><br><span class="line">      <span class="attr">"interface-name"</span>: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>extends</code> 预设的规则模板</li><li><code>rules</code> 自定义规则</li></ul><p>以上是我通常使用的规则，它在推荐规则的基础上，将字符串改为单引号、允许空函数、要求行尾逗号以及不要求接口名称必须以 I 开头。</p><p>完成安装和配置就可以对代码进行检查了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx tslint -p tsconfig.json</span><br></pre></td></tr></table></figure><h2 id="2-2-VS-Code-配置"><a href="#2-2-VS-Code-配置" class="headerlink" title="2.2. VS Code 配置"></a>2.2. VS Code 配置</h2><p>让 VS Code 支持 TSLint 错误显示和自动修复，需要在 VS Code 中安装 <code>TSLint</code> 插件。</p><p>在设置中将 TSLint 插件的 <code>Auto Fix On Save</code> 功能打开即可。</p><h1 id="3-TypeScript-发布-npm-包"><a href="#3-TypeScript-发布-npm-包" class="headerlink" title="3. TypeScript 发布 npm 包"></a>3. TypeScript 发布 npm 包</h1><p>为了兼容 JavaScript 社区，发布到 npm 的包必须是 JavaScript 而不是 TypeScript。</p><p>所以发布一个包的步骤变为：</p><ol><li>编译 TypeScript</li><li>让 npm 只识别编译后的 JavaScript</li><li>发布</li></ol><h2 id="3-1-编译"><a href="#3-1-编译" class="headerlink" title="3.1. 编译"></a>3.1. 编译</h2><p>在 npm scripts 中添加 <code>build</code>：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">    "build": "tsc"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-修改-npm-files"><a href="#3-2-修改-npm-files" class="headerlink" title="3.2. 修改 npm files"></a>3.2. 修改 npm files</h2><p>在 <code>package.json</code> 中新加一个字段 <code>files</code> 指定 npm 识别的文件：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"files": [</span><br><span class="line"><span class="string">"dist/**/*"</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这样当 npm 发布包的时候，就只会放 <code>files</code> 字段中指定的文件打包发布。当然，npm 会自动识别 <code>LICENSE</code>、<code>README.md</code> 和 <code>package.json</code>。</p><p>按照如上配置，最后发布的包的目录结构为：</p><ul><li><code>dist</code><ul><li><code>index.js</code></li><li><code>...</code></li></ul></li><li><code>LICENSE</code></li><li><code>package.json</code></li><li><code>README.md</code></li></ul><h2 id="3-3-自动化"><a href="#3-3-自动化" class="headerlink" title="3.3. 自动化"></a>3.3. 自动化</h2><p>谁都不想每次 <code>npm publish</code> 前都手动运行一次 <code>yarn build</code> ，因此你可以再添加一个 npm scripts：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">    "build": "tsc",</span><br><span class="line">    "prepublishOnly": "yarn bulid"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样每次 <code>npm publish</code> 前就会自动进行编译。</p><h2 id="3-4-避免丢失类型声明"><a href="#3-4-避免丢失类型声明" class="headerlink" title="3.4. 避免丢失类型声明"></a>3.4. 避免丢失类型声明</h2><p>为了兼容 JavaScript 社区，我们往 npm 发布了编译后的 JavaScript 代码，但编译成 JavaScript 后会失去类型声明。</p><p>我们可以在 <code>tsconfig.json</code> 中将 <code>declaration</code> 设为 <code>true</code>，使得编译时输出类型声明文件。</p><p>这样发布的 npm 包目录如下：</p><ul><li><code>dist</code><ul><li><code>index.js</code></li><li><code>index.d.ts</code></li><li><code>…</code></li></ul></li><li><code>LICENSE</code></li><li><code>package.json</code></li><li><code>README.md</code></li></ul><p>这样，JavaScript 和 TypeScript 都可以正常引用编译后的代码，且 TypeScript 还会自动引用同目录下的类型声明文件。（在 VS Code 下，JavaScript 也会自动引用类型声明文件作为代码提示。）</p><h1 id="4-TypeScript-与-webpack"><a href="#4-TypeScript-与-webpack" class="headerlink" title="4. TypeScript 与 webpack"></a>4. TypeScript 与 webpack</h1><h2 id="4-1-webpack-篇"><a href="#4-1-webpack-篇" class="headerlink" title="4.1. webpack 篇"></a>4.1. webpack 篇</h2><p>如果使用 TypeScript 编写浏览器上运行的代码，一般需要配合 webpack 工作。</p><p>首先安装依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add -D webpack webpack-cli awesome-typescript-loader</span><br></pre></td></tr></table></figure><p>在项目根目录下创建 webpack 配置文件 <code>webpack.config.js</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generateConfig</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> mode = name.includes(<span class="string">'min'</span>) ? <span class="string">'production'</span> : <span class="string">'development'</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    entry: <span class="string">'./src/index.ts'</span>,</span><br><span class="line">    mode,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">      rules: [</span><br><span class="line">        &#123;</span><br><span class="line">          test: <span class="regexp">/\.ts?$/</span>,</span><br><span class="line">          loader: <span class="string">'awesome-typescript-loader'</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">    resolve: &#123;</span><br><span class="line">      extensions: [ <span class="string">'.ts'</span>, <span class="string">'.js'</span> ],</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">      filename: <span class="string">`<span class="subst">$&#123;name&#125;</span>.js`</span>,</span><br><span class="line">      path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">      library: <span class="string">'Test'</span>,</span><br><span class="line">      libraryTarget: <span class="string">'umd'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    devtool: <span class="string">'source-map'</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = [generateConfig(<span class="string">'test'</span>), generateConfig(<span class="string">'test.min'</span>)];</span><br></pre></td></tr></table></figure><p>这里的配置文件一次性生成了两个配置：</p><ul><li>在开发环境下编译 <code>index.ts</code> 为 <code>test.js</code>，并生成 source map：在这种情况下，输出代码不会被压缩。</li><li>在生产环境下编译 <code>index.ts</code> 为 <code>test.min.js</code>，并生成 source map：在这种情况下，输出代码会被压缩。</li></ul><p>注意：上述配置第 22 和 23 行定义了输出为 <code>library</code>，即只要运行编译后的代码，入口就会被自动挂载到浏览器的全局下。</p><p>例如 <code>JQuery</code> 可以这么配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">output: &#123;</span><br><span class="line">    filename: <span class="string">'jquery.min.js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    library: <span class="string">'$'</span>,</span><br><span class="line">    libraryTarget: <span class="string">'umd'</span></span><br><span class="line">&#125;,</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>配置完成后，运行下面的命令进行编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx webpack</span><br></pre></td></tr></table></figure><h2 id="4-2-Babel-篇"><a href="#4-2-Babel-篇" class="headerlink" title="4.2. Babel 篇"></a>4.2. Babel 篇</h2><p>为了将新版本的 JavaScript 特性翻译成兼容性更高的 JavaScript，我们需要引入 Babel。</p><p>首先安装依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add -D @babel/core @babel/plugin-transform-runtime @babel/preset-env @babel/preset-typescript @babel/runtime babel-loader</span><br></pre></td></tr></table></figure><p>修改 <code>webpack.config.js</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generateConfig</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> mode = name.includes(<span class="string">'min'</span>) ? <span class="string">'production'</span> : <span class="string">'development'</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    entry: <span class="string">'./src/index.ts'</span>,</span><br><span class="line">    mode,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">      rules: [</span><br><span class="line">        &#123;</span><br><span class="line">          test: <span class="regexp">/\.ts?$/</span>,</span><br><span class="line">          loader: [<span class="string">'babel-loader'</span>, <span class="string">'awesome-typescript-loader'</span>],</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">    resolve: &#123;</span><br><span class="line">      extensions: [ <span class="string">'.ts'</span>, <span class="string">'.js'</span> ],</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">      filename: <span class="string">`<span class="subst">$&#123;name&#125;</span>.js`</span>,</span><br><span class="line">      path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">      library: <span class="string">'Test'</span>,</span><br><span class="line">      libraryTarget: <span class="string">'umd'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    devtool: <span class="string">'source-map'</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = [generateConfig(<span class="string">'test'</span>), generateConfig(<span class="string">'test.min'</span>)];</span><br></pre></td></tr></table></figure><p>唯一的变化是 12 行，<code>loader</code> 中加入了 <code>babel-loader</code>。</p><p>接下来在项目根目录新建 Babel 配置文件 <code>.babelrc</code>，典型配置如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"plugins"</span>: [<span class="string">"@babel/plugin-transform-runtime"</span>],</span><br><span class="line">  <span class="attr">"presets"</span>: [</span><br><span class="line">    <span class="string">"@babel/typescript"</span>,</span><br><span class="line">    [<span class="string">"@babel/env"</span>, &#123;</span><br><span class="line">      <span class="attr">"modules"</span>: <span class="string">"umd"</span>,</span><br><span class="line">      <span class="attr">"targets"</span>: &#123;</span><br><span class="line">        <span class="attr">"browsers"</span>: [ <span class="string">"&gt;1%"</span> ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后的版本将支持使用率大于 1% 的浏览器。</p><h1 id="5-TypeScript-测试"><a href="#5-TypeScript-测试" class="headerlink" title="5. TypeScript 测试"></a>5. TypeScript 测试</h1><h2 id="5-1-使用-Mocha-测试"><a href="#5-1-使用-Mocha-测试" class="headerlink" title="5.1. 使用 Mocha 测试"></a>5.1. 使用 Mocha 测试</h2><p>这里使用的测试框架是 Mocha，断言库是简单优秀的的 power-assert。</p><p>安装依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add -D mocha @types/mocha power-assert espower-typescript</span><br></pre></td></tr></table></figure><p>假定现在目录结构如下：</p><ul><li>index.ts</li><li>test<ul><li>index.test.ts</li></ul></li></ul><p>其中 <code>index.ts</code> ：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>index.test.ts</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> assert = <span class="built_in">require</span>(<span class="string">'assert'</span>);</span><br><span class="line"><span class="keyword">import</span> &#123; add &#125; <span class="keyword">from</span> <span class="string">'../index'</span>;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'Test add function'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  it(<span class="string">'Add'</span>, <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    assert(add(<span class="number">1</span>, <span class="number">2</span>) === <span class="number">3</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在 npm scripts 中添加：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">    "test": "mocha --require espower-typescript/guess test/**/*.ts"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn <span class="built_in">test</span></span><br></pre></td></tr></table></figure><h2 id="5-2-使用-istanbul-生成覆盖率报告"><a href="#5-2-使用-istanbul-生成覆盖率报告" class="headerlink" title="5.2. 使用 istanbul 生成覆盖率报告"></a>5.2. 使用 istanbul 生成覆盖率报告</h2><p>首先安装依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add -D istanbul@1.1.0-alpha.1 ts-node</span><br></pre></td></tr></table></figure><p>注意这里必须安装 <code>1.1.0-alpha.1</code> 版本的 <code>istanbul</code>。</p><p>在 npm scripts 中添加：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">    "coverage": "istanbul cover -e .ts _mocha -- --require ts-node/register test/**/*.ts"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里用来生成覆盖率的命令有些复杂，解析如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">istanbul \<span class="comment"># istanbul 命令</span></span><br><span class="line">cover \<span class="comment"># istanbul 子命令</span></span><br><span class="line">-e .ts \<span class="comment"># istanbul 参数，指定 .ts 文件</span></span><br><span class="line">_mocha \<span class="comment"># 在同一个进程内运行 mocha 保证 istanbul 能获得输出</span></span><br><span class="line">-- \<span class="comment"># 两短横线后的参数会传递给 mocha 而非 istanbul</span></span><br><span class="line">--require ts-node/register \<span class="comment"># 使用 ts-node 编译</span></span><br><span class="line"><span class="built_in">test</span>/**/*.ts<span class="comment"># 测试文件</span></span><br></pre></td></tr></table></figure><p>运行 <code>yarn coverage</code> 就会跑完测试代码并在 <code>coverage</code> 目录下生成覆盖率报告。建议将 <code>coverage</code> 添加到 <code>.gitignore</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍我入坑 TypeScript 以后总结的一些相关配置，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TypeScript 安装、配置与调试&lt;/li&gt;
&lt;li&gt;TSLint 配置&lt;/li&gt;
&lt;li&gt;TypeScript 编写与发布 npm 包&lt;/li&gt;
&lt;li&gt;TypeScript 与 webpack、babel&lt;/li&gt;
&lt;li&gt;TypeScript 测试与覆盖率&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Tutorial" scheme="http://blog.andiedie.cn/categories/Tutorial/"/>
    
    
  </entry>
  
  <entry>
    <title>基于 Android Accessibility 实现一键拨打微信电话</title>
    <link href="http://blog.andiedie.cn/posts/df57/"/>
    <id>http://blog.andiedie.cn/posts/df57/</id>
    <published>2018-12-01T08:34:54.000Z</published>
    <updated>2019-05-10T13:08:07.545Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文对小项目 <a href="https://github.com/Andiedie/QuickWeChatCall" target="_blank" rel="noopener">QuickWeChatCall</a> 进行了简要的回顾。</p><a id="more"></a><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><h2 id="1-1-动机"><a href="#1-1-动机" class="headerlink" title="1.1. 动机"></a>1.1. 动机</h2><p>奶奶非常喜欢和我跟姐姐视频聊天，但是微信的视频步骤实在太过复杂，对于打电话都有困难的奶奶来说几乎不可能独立使用的。为此我编写了 QuickWeChatCall 这个工具，用于帮助需要的人一键发起微信视频。</p><p>ビデオチャットしましょう、おばあちゃん。:-)</p><p>项目地址：<a href="https://github.com/Andiedie/QuickWeChatCall" target="_blank" rel="noopener">QuickWeChatCall</a></p><p>下载：<a href="https://github.com/Andiedie/QuickWeChatCall/releases" target="_blank" rel="noopener">Release</a></p><p>使用教程：<a href="https://github.com/Andiedie/QuickWeChatCall#%E4%BD%BF%E7%94%A8" target="_blank" rel="noopener">Usage</a></p><h2 id="1-2-结果"><a href="#1-2-结果" class="headerlink" title="1.2. 结果"></a>1.2. 结果</h2><p>运行截图：</p><p><img src="/assets/screenshot.gif" alt="img"></p><p>实现了以下功能：</p><ul><li>一键发起视频聊天</li><li>自动接听视频 / 语音聊天</li><li>快捷联系人列表</li></ul><h2 id="1-3-启发"><a href="#1-3-启发" class="headerlink" title="1.3. 启发"></a>1.3. 启发</h2><p>在自己开发之前，先测试了两个网络上提供的解决方案：</p><ol><li><a href="https://github.com/hyb1996/Auto.js" target="_blank" rel="noopener">Auto.js</a>，支持使用 JavaScript 操控 Android 的无障碍服务。优点是开发迅速，只需要几行 JavaScript 代码就可以了，缺点则是太过硬核，不适合老年人使用。</li><li>由 <a href="https://www.zhihu.com/people/wen-zi-wen-11/activities" target="_blank" rel="noopener">Mozzie</a> 在<a href="https://www.zhihu.com/question/61326926" target="_blank" rel="noopener">一个知乎回答</a> 中提供的基于 Android 无障碍服务的一键视频应用。但在试用之后发现作者基本只是写了个 Demo，几乎没有易用性，而且核心功能——一键发起视频，已经无法使用了。</li></ol><p>最后我决定同样基于 Android 无障碍服务，开发一个简单易用的一键发起视频聊天工具。也就诞生了 QuickWeChatCall 项目。</p><h2 id="1-4-原理"><a href="#1-4-原理" class="headerlink" title="1.4. 原理"></a>1.4. 原理</h2><p>原理非常简单，就是利用 <a href="https://developer.android.com/guide/topics/ui/accessibility/" target="_blank" rel="noopener">Android Accessibility Service</a>，监听微信的 UI 变动。根据一定的步骤，寻找指定的 UI 组件，执行点击操作即可。</p><h1 id="2-细节"><a href="#2-细节" class="headerlink" title="2. 细节"></a>2. 细节</h1><h2 id="2-1-无障碍权限"><a href="#2-1-无障碍权限" class="headerlink" title="2.1. 无障碍权限"></a>2.1. 无障碍权限</h2><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>无障碍服务的权限声明需要在 <code>AndroidManifest.xml</code> 中声明：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">service</span></span></span><br><span class="line"><span class="tag">             <span class="attr">android:name</span>=<span class="string">"无障碍服务类名"</span></span></span><br><span class="line"><span class="tag">             <span class="attr">android:label</span>=<span class="string">"无障碍服务名称"</span></span></span><br><span class="line"><span class="tag">             <span class="attr">android:permission</span>=<span class="string">"android.permission.BIND_ACCESSIBILITY_SERVICE"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.accessibilityservice.AccessibilityService"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">android:name</span>=<span class="string">"android.accessibilityservice"</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">android:resource</span>=<span class="string">"@xml/accessibility_config"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在 <code>xml/accessibility_config</code> 中声明：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">accessibility-service</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:accessibilityEventTypes</span>=<span class="string">"typeAllMask"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:accessibilityFeedbackType</span>=<span class="string">"feedbackSpoken"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:accessibilityFlags</span>=<span class="string">"flagIncludeNotImportantViews"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:canRetrieveWindowContent</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:description</span>=<span class="string">"无障碍服务描述"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:notificationTimeout</span>=<span class="string">"100"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:packageNames</span>=<span class="string">"监听包名"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>这里只解释几个关键的字段</p><ul><li><code>无障碍服务类名</code>：提供无障碍服务的服务类的名称，后续细谈</li><li><code>无障碍服务名称</code>：在系统设置中显示的无障碍服务的名称</li><li><code>无障碍服务描述</code>：在系统设置中显示的无障碍服务的描述</li><li><code>监听包名</code>：无障碍服务监听的包名，比如这里我们需要监听微信的 UI 更新，因此包名就是微信的包名 <code>com.tencent.mm</code></li></ul><h3 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h3><p>无障碍服务的授权比较特殊，不像其他权限一样可以通过 Dialog 的方式提示用户授权，而是需要在系统设置的无障碍服务中手动开启。</p><p>因此最好的办法就是在启动的时候检查无障碍权限情况，如果没有得到授权就转跳到系统设置界面。</p><p>检查无障碍权限的代码，参考了 Stack Overflow 上的<a href="https://stackoverflow.com/a/5106419" target="_blank" rel="noopener">答案</a>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isAccessibilitySettingsOn</span><span class="params">(Context mContext)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> accessibilityEnabled = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span> String service = getPackageName() + <span class="string">"/"</span> + AccessibilityService.class.getCanonicalName();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        accessibilityEnabled = Settings.Secure.getInt(</span><br><span class="line">            mContext.getApplicationContext().getContentResolver(),</span><br><span class="line">            android.provider.Settings.Secure.ACCESSIBILITY_ENABLED);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Settings.SettingNotFoundException e) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"Error finding setting, default accessibility to not found: "</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    TextUtils.SimpleStringSplitter mStringColonSplitter = <span class="keyword">new</span> TextUtils.SimpleStringSplitter(<span class="string">':'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (accessibilityEnabled == <span class="number">1</span>) &#123;</span><br><span class="line">        String settingValue = Settings.Secure.getString(</span><br><span class="line">            mContext.getApplicationContext().getContentResolver(),</span><br><span class="line">            Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES);</span><br><span class="line">        <span class="keyword">if</span> (settingValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mStringColonSplitter.setString(settingValue);</span><br><span class="line">            <span class="keyword">while</span> (mStringColonSplitter.hasNext()) &#123;</span><br><span class="line">                String accessibilityService = mStringColonSplitter.next();</span><br><span class="line">                <span class="keyword">if</span> (accessibilityService.equalsIgnoreCase(service)) &#123;</span><br><span class="line">                    Log.v(TAG, <span class="string">"***ACCESSIBILITY IS ENABLED***"</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Log.v(TAG, <span class="string">"***ACCESSIBILITY IS DISABLED***"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跳转到系统无障碍服务设置界面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startActivity(<span class="keyword">new</span> Intent(Settings.ACTION_ACCESSIBILITY_SETTINGS));</span><br></pre></td></tr></table></figure><h2 id="2-2-无障碍服务"><a href="#2-2-无障碍服务" class="headerlink" title="2.2. 无障碍服务"></a>2.2. 无障碍服务</h2><p>当应用开启无障碍服务权限之后，注册的无障碍服务类就会在后台运行。当注册包名的 UI 发生变化是，就会触发事件，并调用无障碍服务类中相应的回调。这些事件可能是，内容变更、创建或删除节点等。</p><p>所以核心逻辑就是在无障碍服务类中，处理对应的事件。</p><h2 id="2-3-逻辑"><a href="#2-3-逻辑" class="headerlink" title="2.3. 逻辑"></a>2.3. 逻辑</h2><p>整个发起微信视频的步骤经过多次调整最后确定为：</p><ol><li>打开微信</li><li>点击微信下方导航条中的“联系人”</li><li>点击联系人界面的“标签“</li><li>点击标签列表中的”微信一键视频“标签</li><li>点击对应的微信好友</li><li>点击”视频聊天“按钮</li><li>选择”视频聊天“</li></ol><p>因此，程序运行的逻辑就是</p><ol><li>打开微信，将当前步骤设定为上述步骤 2</li><li>等待 UI 更新</li><li>UI 更新后，在界面中寻找该步骤需要点击的元素，点击</li><li>将步骤设置为下一步</li><li>回到 2，重复执行，直到结束</li></ol><h2 id="2-4-去抖动"><a href="#2-4-去抖动" class="headerlink" title="2.4. 去抖动"></a>2.4. 去抖动</h2><p>因为 UI 更新造成的事件可能非常密集，例如家在列表的时候，有可能每一个列表项的加入都会造成一次事件回调。而程序其实只需要在一次 UI 更新的结束阶段，寻找指定元素就可以了。所以需要一定的去抖动机制。</p><p>原理其实也非常简单，可以参照 Lodash 中的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAccessibilityEvent</span><span class="params">(AccessibilityEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (finished) &#123;</span><br><span class="line">        finished = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Log.v(TAG, <span class="string">"bounce"</span>);</span><br><span class="line">        handler.removeCallbacks(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                _onAccessibilityEvent(input);</span><br><span class="line">                finished = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    input = event;</span><br><span class="line">    handler = <span class="keyword">new</span> Handler();</span><br><span class="line">    handler.postDelayed(runnable, WAIT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-坑"><a href="#3-坑" class="headerlink" title="3. 坑"></a>3. 坑</h1><h2 id="3-1-无障碍服务授权期限"><a href="#3-1-无障碍服务授权期限" class="headerlink" title="3.1. 无障碍服务授权期限"></a>3.1. 无障碍服务授权期限</h2><p>获得无障碍服务的权限之后，无障碍服务类就在后台运行了。但如果这时候由于任何情况（关机、重启、后台被杀、自身异常等等），无障碍服务类关闭了，那么无障碍服务的权限就会自动丢失，必须重新授权。</p><h2 id="3-2-微信首页组件搜索"><a href="#3-2-微信首页组件搜索" class="headerlink" title="3.2. 微信首页组件搜索"></a>3.2. 微信首页组件搜索</h2><p>无障碍服务提供了一个函数 <code>findAccessibilityNodeInfosByText</code> 用来搜索当前布局中的元素，但是不知为何，在微信首页调用这个函数搜索不到任何内容。然而自己手动遍历的话，却可以搜索到。</p><p>因此我手动实现了一个深度优先搜索的多属性搜索函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> AccessibilityNodeInfo <span class="title">findNode</span><span class="params">(AccessibilityNodeInfo root, Property type, String text)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> satisfied = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> TEXT:</span><br><span class="line">            satisfied = root.getText() != <span class="keyword">null</span> &amp;&amp; text.contentEquals(root.getText());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> CLASS_NAME:</span><br><span class="line">            satisfied = root.getClassName() != <span class="keyword">null</span> &amp;&amp; text.contentEquals(root.getClassName());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DESCRIPTION:</span><br><span class="line">            satisfied = root.getContentDescription() != <span class="keyword">null</span> &amp;&amp; text.contentEquals(root.getContentDescription());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (satisfied) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; root.getChildCount(); i++) &#123;</span><br><span class="line">            AccessibilityNodeInfo result = findNode(root.getChild(i), type, text);</span><br><span class="line">            <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    root.recycle();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-魅族调试"><a href="#3-3-魅族调试" class="headerlink" title="3.3. 魅族调试"></a>3.3. 魅族调试</h2><p>在模拟器上装微信遇到一些问题，因此我就直接在手头唯一的魅蓝 5 上实机调试。但是发现在魅蓝 5 上无论如何都获取不到 Log 信息，后来发现需要在 <code>系统设置 -&gt; 开发者选项 -&gt; 性能优化 -&gt; 高级日志输出</code> 中选择 <code>全部允许</code>。</p><h1 id="4-后来"><a href="#4-后来" class="headerlink" title="4. 后来"></a>4. 后来</h1><p>后来由于，上面也提到的无障碍权限总是需要重复授权的问题，虽然简单开发完了这个工具，最后还是放弃了使用。毕竟对于奶奶来说，如果一不小心开关机或者清理了后台，重新授权确实太复杂了。</p><p>最后的解决方法是，FaceTime 😂</p><p>没错，Apple 大法好。通过捷径配合 FaceTime，奶奶可以在 iPad 上一键发起视频聊天。</p><p>唯一的缺点大概就是必须是对方也必须是苹果设备，恰好我和姐姐都是✌️。</p><p>感谢洛伊酱 ❤️ 提供的 iPad 呀，奶奶超开心。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文对小项目 &lt;a href=&quot;https://github.com/Andiedie/QuickWeChatCall&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;QuickWeChatCall&lt;/a&gt; 进行了简要的回顾。&lt;/p&gt;
    
    </summary>
    
      <category term="Development" scheme="http://blog.andiedie.cn/categories/Development/"/>
    
    
  </entry>
  
  <entry>
    <title>随机数是如何生成的</title>
    <link href="http://blog.andiedie.cn/posts/d02e/"/>
    <id>http://blog.andiedie.cn/posts/d02e/</id>
    <published>2018-10-12T07:36:13.000Z</published>
    <updated>2019-05-10T13:08:07.549Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文主要介绍随机数的概念与分类，以及简单的统计学伪随机数算法。</p><a id="more"></a><h1 id="1-随机数概念"><a href="#1-随机数概念" class="headerlink" title="1. 随机数概念"></a>1. 随机数概念</h1><p>这里我们主要讨论的是密码学范畴的随机数。随机数的随机性检验可以分为三个标准：</p><ol><li><strong>统计学伪随机性。</strong>在给定的随机比特流样本中，1 的数量大致等于 0 的数量。也就是说，如果我们把一个（包含足够多随机数的）随机序列里的每个随机数数转化为二进制数，并首尾相接形成一个串，那么这个串中的 1 和 0 的数量应该大致相等。满足这类要求的数字，人类“一眼看上去”是随机的。</li><li><strong>密码学安全伪随机性。</strong>给定一定长度的随机序列，在多项式时间内演算出随机序列的任何部分的概率低于 50%。例如即使给定随机序列的前 100 个随机数，也无法在有效地算出第 101 个随机数是什么。这样的伪随机数序列难以被预测。</li><li><strong>真随机性。</strong>随机序列不可重现。也就是说，给定相同的参数，多次计算出的结果是不同的。由于计算机算法都具备<strong>确定性</strong>的特征，因此真随机数无法通过算法生成。</li></ol><p>相应的，随机数被分为三类：</p><ol><li><strong>统计学伪随机数。</strong>仅符合第一个标准的随机数。也就是只是人类“一眼看上去”觉得随机而已。</li><li><strong>密码学安全的伪随机数。</strong>符合前两个标准的的随机数，也就是说不仅人类觉得随机，而且随机序列难以预测。这种随机数可以通过<strong>密码学安全伪随机数生成器（ CSPRNG ）</strong>计算得出。</li><li><strong>真随机数。</strong>同时符合三个条件的随机数，主流观点认为只有通过量子力学的内禀随机性生成的随机数才是真随机数。</li></ol><h1 id="2-统计学伪随机数算法"><a href="#2-统计学伪随机数算法" class="headerlink" title="2. 统计学伪随机数算法"></a>2. 统计学伪随机数算法</h1><h2 id="2-1-平方取中法-Middle-square-method"><a href="#2-1-平方取中法-Middle-square-method" class="headerlink" title="2.1. 平方取中法 Middle-square method"></a>2.1. 平方取中法 Middle-square method</h2><h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><p>该方法由冯 · 诺伊曼在 1946 年提出，算法非常简单：</p><ol><li>选择一个 m 位数 $N_i$ 作为种子</li><li>计算 $N_i^2$</li><li>若 $N_i^2$ 不足 2m 位，在前补 0。选择这个数中间 m 个位的数，即 $10^{\lfloor m/2 \rfloor}$ 至 $10^{\lfloor m/2 \rfloor + m}$ 的数，将结果作为 $N_{i+1}$。</li></ol><p>以 675248 为种子为例，675248 的平方为 455959861504，最后取最中间的 6 位数字作为结果：959861。</p><p><img src="/assets/1539444972231.png" alt="1539444972231"></p><h3 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h3><p>Python 实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">seed = <span class="string">'675248'</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">middleSquare</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="keyword">global</span> seed</span><br><span class="line">  length = len(seed)</span><br><span class="line">  square =  int(seed) * int(seed)</span><br><span class="line">  seed = str(square).zfill(length * <span class="number">2</span>)[int(length / <span class="number">2</span>):int(length / <span class="number">2</span>) + length]</span><br><span class="line">  <span class="keyword">return</span> int(seed)</span><br></pre></td></tr></table></figure><h3 id="体验"><a href="#体验" class="headerlink" title="体验"></a>体验</h3><p data-height="344" data-theme-id="0" data-slug-hash="BGJxVE" data-default-tab="result" data-user="Andiedie" data-pen-title="BGJxVE" class="codepen">See the Pen <a href="https://codepen.io/Andiedie/pen/BGJxVE/" target="_blank" rel="noopener">BGJxVE</a> by Andie (<a href="https://codepen.io/Andiedie" target="_blank" rel="noopener">@Andiedie</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul><li>总体周期过短。对于 n 位数的种子，它的循环周期总是小于等于 $8^n$。</li><li>如果中间 n 位都是零，接下来就会永远输出 0。</li><li>如果种子的前半部分为 0，那么后续的随机序列很快就会变成 0。你可以尝试在上面的 <code>Seed</code> 位置填入<code>0099</code>，并点击多次 <code>Get Next</code>。</li><li>随机队列卡住不变。例如当种子是 0100、2500、3792、7600 时，随机序列将永远不会改变。而这只是四位数种子时的情况。</li><li>一些特殊的序列还会产生极短的周期。例如 0540 -&gt; 2916 -&gt; 5030 -&gt; 3009。事实上，00 ~ 99 这 100 个二位数种子，没有任何一个周期可以超过 14。</li></ul><h2 id="2-2-线性同余方法-Linear-congruential-generator"><a href="#2-2-线性同余方法-Linear-congruential-generator" class="headerlink" title="2.2. 线性同余方法 Linear congruential generator"></a>2.2. 线性同余方法 Linear congruential generator</h2><h3 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h3><p>线性同于方法（简称 LCG ），原理如下：</p><p>$X_{n+1}= (aX_n+c) \mod m$</p><p>其中：</p><ul><li>$m$ 是模数，$m &gt; 0$</li><li>$a$ 是乘数，$0 &lt; a &lt; m$</li><li>$c$ 是增量，$0 \le c &lt; m$</li><li>$X_0$ 是种子，$0 \le X_0 &lt; m$</li></ul><p>线性同余方法就通过不断计算该式子，递推地算出随机序列。</p><p>需要注意的是，LCG 对参数的选择极其敏感。好的参数选择，可以使 LCG 产生的随机数队列序列拥有很长的周期，解决上述平方取中法的缺陷。但是糟糕的参数选择也会使得 LCG 的表现非常差。</p><p>一些常用的参数：</p><table><thead><tr><th>来源</th><th>模数 $m$</th><th>乘数 $a$</th><th>增量 $c$</th></tr></thead><tbody><tr><td>C++11 的 <code>minstd_rand0</code></td><td>$2^{31}-1$</td><td>16807</td><td>0</td></tr><tr><td>C++11 的 <code>minstd_rand</code></td><td>$2^{31}-1$</td><td>48271</td><td>0</td></tr><tr><td>Java 的 <code>java.util.Random</code></td><td>$2^{48}$</td><td>25214903917</td><td>11</td></tr></tbody></table><p>要注意的是，LCG 并不总是将计算结果的全部二进制位都作为输出。比如 Java 在每次迭代中使用 48 位进行计算，但是只返回结果中的 32 个高有效位。这是因为（统计上）使用这种截断方法可以拥有更长的周期，产生更加好的随机序列。</p><h3 id="简单实现-1"><a href="#简单实现-1" class="headerlink" title="简单实现"></a>简单实现</h3><p>Python 实现如下，这里的参数使用的是与 C++11 的 <code>minstd_rand</code> 相同的参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">seed = <span class="number">1</span></span><br><span class="line">m = <span class="number">2</span>**<span class="number">31</span> - <span class="number">1</span></span><br><span class="line">a = <span class="number">48271</span></span><br><span class="line">c = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">linearCongruential</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="keyword">global</span> seed</span><br><span class="line">  seed = (a * seed + c) % m</span><br><span class="line">  <span class="keyword">return</span> seed</span><br></pre></td></tr></table></figure><h3 id="体验-1"><a href="#体验-1" class="headerlink" title="体验"></a>体验</h3><p data-height="429" data-theme-id="0" data-slug-hash="KrZRbd" data-default-tab="result" data-user="Andiedie" data-pen-title="随机数-线性同余法" class="codepen">See the Pen <a href="https://codepen.io/Andiedie/pen/KrZRbd/" target="_blank" rel="noopener">随机数-线性同余法</a> by Andie (<a href="https://codepen.io/Andiedie" target="_blank" rel="noopener">@Andiedie</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><p>LCG 速度快，且非常省空间（通常只需要 32 位或者 64 位）。且当周期足够大时，LCG 甚至可以通过一些严格的统计测试。</p><p>缺点：</p><p>通过线性同余方法构建的伪随机数生成器的参数可以轻易地由其输出的随机序列演算得知，所以此种伪随机数生成器属于统计学伪随机数生成器。</p><p>此外，LCG 产生的随机序列的最大周期是模数 $m$，通常是 $2^{32}$ 左右，这对于大多数场景来说已经足够了。不过对于某些应用来说，这样的周期还不够大。</p><h2 id="2-3-梅森旋转算法-Mersenne-twister"><a href="#2-3-梅森旋转算法-Mersenne-twister" class="headerlink" title="2.3. 梅森旋转算法 Mersenne twister"></a>2.3. 梅森旋转算法 Mersenne twister</h2><p>梅森旋转算法松本真和西村拓士在 1997 年开发，可以快速产生高质量的伪随机数，修正了古典随机数发生算法的很多缺陷，是 R、Python、Ruby、IDL、Free Pascal、PHP、Maple、MATLAB、GNU 多重精度运算库和 GSL 的默认伪随机数产生器。从 C++11 开始，C++ 也可以使用这种算法。</p><h3 id="算法描述-2"><a href="#算法描述-2" class="headerlink" title="算法描述"></a>算法描述</h3><p>目前使用最广泛的是 MT19937，可以产生 32 位的整数序列。整个算法主要分为三个阶段：</p><ol><li>初始化：根据种子生成初始状态。</li><li>迭代：迭代产生下一个状态。</li><li>提取：从当前状态中提取随机数。</li></ol><h3 id="简单实现-2"><a href="#简单实现-2" class="headerlink" title="简单实现"></a>简单实现</h3><p>Python 实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MT19937</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, seed = <span class="number">0</span>)</span>:</span></span><br><span class="line">    self.state = [<span class="number">0</span>] * <span class="number">624</span></span><br><span class="line">    self.index = <span class="number">0</span></span><br><span class="line">    self.state[<span class="number">0</span>] = seed</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">624</span>):</span><br><span class="line">      self.state[i] = (<span class="number">0x6c078965</span> * (self.state[i - <span class="number">1</span>] ^ (self.state[i - <span class="number">1</span>] &gt;&gt; <span class="number">30</span>)) + i) &amp; <span class="number">0xffffffff</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">generate_numbers</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">624</span>):</span><br><span class="line">      y = (self.state[i] &amp; <span class="number">0x80000000</span>) + (self.state[(i + <span class="number">1</span>) % <span class="number">624</span>] &amp; <span class="number">0x7fffffff</span>)</span><br><span class="line">      self.state[i] = self.state[(i + <span class="number">397</span>) % <span class="number">624</span>] ^ (y &gt;&gt; <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">if</span> y % <span class="number">2</span>:</span><br><span class="line">        self.state[i] = self.state[i] ^ <span class="number">0x9908b0df</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">extract_number</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> self.index == <span class="number">0</span>:</span><br><span class="line">      self.generate_numbers()</span><br><span class="line">    y = self.state[self.index]</span><br><span class="line">    y ^= y &gt;&gt; <span class="number">11</span></span><br><span class="line">    y ^= (y &lt;&lt; <span class="number">7</span>) &amp; <span class="number">0x9d2c5680</span></span><br><span class="line">    y ^= (y &lt;&lt; <span class="number">15</span>) &amp; <span class="number">0xefc60000</span></span><br><span class="line">    y ^= y &gt;&gt; <span class="number">18</span></span><br><span class="line">    self.index = (self.index + <span class="number">1</span>) % <span class="number">624</span></span><br><span class="line">    <span class="keyword">return</span> y</span><br></pre></td></tr></table></figure><h3 id="体验-2"><a href="#体验-2" class="headerlink" title="体验"></a>体验</h3><p data-height="347" data-theme-id="0" data-slug-hash="BGJxvg" data-default-tab="result" data-user="Andiedie" data-pen-title="BGJxvg" class="codepen">See the Pen <a href="https://codepen.io/Andiedie/pen/BGJxvg/" target="_blank" rel="noopener">BGJxvg</a> by Andie (<a href="https://codepen.io/Andiedie" target="_blank" rel="noopener">@Andiedie</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p><ul><li>周期非常长，MT19973 的周期可以达到 $2^{19973} - 1$。</li><li>均匀性好。</li><li>速度非常快，基本都是位运算。</li></ul><p>缺点：</p><ul><li>空间成本高，需要 2.5 KB 的缓存空间。（之后原作者又推出了仅占用 127 bits 的 TinyMT ）</li><li>不是密码学安全的伪随机数生成器。由于提取函数是可逆的位运算，暴露了内部状态，因此梅森旋转算法是可以爆破的。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>随机数. (2018, August 21). Retrieved from 维基百科, 自由的百科全书: <a href="https://zh.wikipedia.org/w/index.php?title=%E9%9A%8F%E6%9C%BA%E6%95%B0&amp;oldid=50958514" target="_blank" rel="noopener">https://zh.wikipedia.org/w/index.php?title=%E9%9A%8F%E6%9C%BA%E6%95%B0&amp;oldid=50958514</a></li><li>密码学安全伪随机数生成器. (2018, October 9). Retrieved from 维基百科, 自由的百科全书: <a href="https://zh.wikipedia.org/w/index.php?title=%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AE%89%E5%85%A8%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8&amp;oldid=51577215" target="_blank" rel="noopener">https://zh.wikipedia.org/w/index.php?title=%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AE%89%E5%85%A8%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8&amp;oldid=51577215</a></li><li>平方取中法. (2018, April 29). Retrieved from 维基百科, 自由的百科全书: <a href="https://zh.wikipedia.org/w/index.php?title=%E5%B9%B3%E6%96%B9%E5%8F%96%E4%B8%AD%E6%B3%95&amp;oldid=49350258" target="_blank" rel="noopener">https://zh.wikipedia.org/w/index.php?title=%E5%B9%B3%E6%96%B9%E5%8F%96%E4%B8%AD%E6%B3%95&amp;oldid=49350258</a></li><li>线性同余方法. (2018, April 29). Retrieved from 维基百科, 自由的百科全书: <a href="https://zh.wikipedia.org/w/index.php?title=%E7%B7%9A%E6%80%A7%E5%90%8C%E9%A4%98%E6%96%B9%E6%B3%95&amp;oldid=49350290" target="_blank" rel="noopener">https://zh.wikipedia.org/w/index.php?title=%E7%B7%9A%E6%80%A7%E5%90%8C%E9%A4%98%E6%96%B9%E6%B3%95&amp;oldid=49350290</a></li><li>梅森旋转算法. (2018, July 30). Retrieved from 维基百科, 自由的百科全书: <a href="https://zh.wikipedia.org/w/index.php?title=%E6%A2%85%E6%A3%AE%E6%97%8B%E8%BD%AC%E7%AE%97%E6%B3%95&amp;oldid=50644255" target="_blank" rel="noopener">https://zh.wikipedia.org/w/index.php?title=%E6%A2%85%E6%A3%AE%E6%97%8B%E8%BD%AC%E7%AE%97%E6%B3%95&amp;oldid=50644255</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍随机数的概念与分类，以及简单的统计学伪随机数算法。&lt;/p&gt;
    
    </summary>
    
      <category term="Principle" scheme="http://blog.andiedie.cn/categories/Principle/"/>
    
    
  </entry>
  
  <entry>
    <title>实训报告 2nd</title>
    <link href="http://blog.andiedie.cn/posts/5fe4/"/>
    <id>http://blog.andiedie.cn/posts/5fe4/</id>
    <published>2018-04-16T12:20:39.000Z</published>
    <updated>2019-05-10T13:08:07.546Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近主要按照师兄的指导，读论文了解ResNet，读TensorFlow官方的ResNet实现，简单修改网络以及了解DeepFashion数据集。</p><a id="more"></a><h1 id="1-残差网络"><a href="#1-残差网络" class="headerlink" title="1. 残差网络"></a>1. 残差网络</h1><h2 id="1-1-理解残差网络"><a href="#1-1-理解残差网络" class="headerlink" title="1.1. 理解残差网络"></a>1.1. 理解残差网络</h2><h3 id="1-1-1-The-deeper-the-better"><a href="#1-1-1-The-deeper-the-better" class="headerlink" title="1.1.1. The deeper, the better"></a>1.1.1. The deeper, the better</h3><p>已经有大量实验以及实践证明，网络的层级结构越深，网络的表现就越好。</p><ul><li><a href="https://arxiv.org/abs/1409.1556" target="_blank" rel="noopener">Very deep convolutional networks for large-scale image recognition</a> 和 <a href="https://arxiv.org/abs/1409.4842" target="_blank" rel="noopener">Going deeper with convolutions</a> 两篇论文均表明网络的深度至关重要。</li><li>在<a href="http://www.image-net.org/" target="_blank" rel="noopener">ImageNet</a>数据集中表现优秀的模型，都具有“非常深”的网络，深度在16到30之间。</li><li>许多重要的视觉识别任务也通过使用非常深的模型，取得了非凡的效果。</li></ul><h3 id="1-1-2-The-deeper-the-network-the-harder-it-is-to-train"><a href="#1-1-2-The-deeper-the-network-the-harder-it-is-to-train" class="headerlink" title="1.1.2. The deeper the network, the harder it is to train"></a>1.1.2. The deeper the network, the harder it is to train</h3><p>既然网络深度如此重要，那么训练出更好的网络，岂不是就和不断堆叠网络深度一样简单？</p><p>当然不是！不断加深的网络会带来两个问题：</p><ul><li><p><strong>梯度消失/爆炸 Vanishing/Exploding Gradients</strong></p><p>更深的网络遇到的第一个问题就是臭名昭著的梯度消失/爆炸问题，它使得网络一开始就难以收敛。不过现在这个问题很大程度上已经可以通过采用<strong>标准初始化 Normalized Initialization</strong>和<strong>中间层标准化 Intermediate Normalization</strong>解决。</p></li><li><p><strong>退化 Degradation</strong></p><p>虽然通过上述的方法，我们可以使数十层的网络通过<strong>随机梯度下降  SGD</strong>开始收敛 ，但是退化现象接踵而至：随着网络深度的增加，模型的准确度会在某个深度达到饱和，之后迅速下降。我们暂时把准确度饱和时的深度称为<em>适宜深度</em>，退化现象表现为，当网络深度超过适宜深度时，训练误差会越来越高，这也会导致更高的测试误差。如下图：</p><p><img src="/assets/yimbhsyire7asmfnfs2uzkrdqbe4b43y.png" alt="1524117726549"></p><p>这是20层和56层的简单网络再<a href="https://www.cs.toronto.edu/~kriz/cifar.html" target="_blank" rel="noopener">CIFAR-10</a>数据集上的训练误差和测试误差。可以看出，由于退化现象，更深的网络反而表现更差。</p></li></ul><h3 id="1-1-3-残差映射-Residual-Mapping"><a href="#1-1-3-残差映射-Residual-Mapping" class="headerlink" title="1.1.3. 残差映射 Residual Mapping"></a>1.1.3. 残差映射 Residual Mapping</h3><p>通常情况下，我们正利用数个堆叠的层拟合一个目标映射$\mathcal{H}(x)$。但在深度残差学习框架 deep residual learning framework 中，我们不直接拟合目标映射$\mathcal{H}(x)$，而是这几个堆叠的层拟合另一个映射$\mathcal{F}(x) := \mathcal{H}(x) - x$。此时，目标映射被重写为$\mathcal{F}(x) + x$。</p><p>这里有一个假设：残差映射$\mathcal{H}(x)-x$比原映射$\mathcal{H}(x)$更容易优化。</p><h4 id="那么为什么要使用残差学习？"><a href="#那么为什么要使用残差学习？" class="headerlink" title="那么为什么要使用残差学习？"></a>那么为什么要使用残差学习？</h4><p>引用<a href="https://www.zhihu.com/question/53224378/answer/159102095" target="_blank" rel="noopener">theone</a>的直觉描述：</p><p>假设这个网络的目标映射是输出5，输出5.1，即$\mathcal{H}(5)=5.1$。如果直接拟合这个映射，那么可以得到一个拟合结果，函数$\mathcal{F’}(5)=5.1$。引入残差后，拟合结果的函数变为$\mathcal{F}(5)=0.1$（其中$\mathcal{H}(5)=\mathcal{F}(5)+5$ ）。</p><p>现在假设输出的要求从5.1变为了5.2，即$\mathcal{H}(5)=5.2$。那么直接拟合的函数$\mathcal{F’}(5)$从5.1到5.2变化了$1/51\approx0.2$，而引入残差的映射$\mathcal{F}(5)$从0.1到0.2变化了100%。可以看出，<strong>引入残差映射对于输出的变化更加敏感，对权重的调整作用更大</strong>。</p><p>因此，残差学习的思想可以理解为：<strong>去掉相同的主体部分，从而突出微小的变化。</strong></p><h3 id="1-1-4-快捷连接-Shortcut-Connections"><a href="#1-1-4-快捷连接-Shortcut-Connections" class="headerlink" title="1.1.4. 快捷连接 Shortcut Connections"></a>1.1.4. 快捷连接 Shortcut Connections</h3><p>上述映射$\mathcal{F}(x)+x$由一个快捷连接实现，如下图：</p><p><img src="/assets/nyptrwwjxg0jx5gevpu5650srbg59h1x.png" alt="1524120342408"></p><p>在这里，快捷连接是一个恒等映射，直接被添加到整个堆叠层的输出$\mathcal{F}(x)$上，得到$\mathcal{F}(x)+x$。恒等快捷连接不仅不增加额外的参数，而且不增加计算复杂度。</p><p>公式表示为：</p><p>$$y=\mathcal{F}(x, {W_i}) + x$$</p><p>这里要求$x$与$\mathcal{F}(x)$具有相同的维度，如果维度不同，则使用简单的线性投影$W_s$来匹配维度：</p><p>$$y=\mathcal{F}(x,W_i)+W_sx$$</p><h4 id="为什么要使用恒等映射？"><a href="#为什么要使用恒等映射？" class="headerlink" title="为什么要使用恒等映射？"></a>为什么要使用恒等映射？</h4><p>实际上在ResNet原团队的另一篇论文[2]中解释了这个问题。在文章中，作者设计了六种快捷连接的映射：</p><p><img src="/assets/53y55iw2ryqrba2mhspyhfa3vvlyqtm1.png" alt="1524134061037"></p><p>实验证明，恒等映射的误差衰减最快，误差也最小，其他快捷连接的形式都产生了较大的误差（有的甚至超过了20%）：</p><p><img src="/assets/x04nhx13u2t9vcsss8y7iqi1z8x6xxnn.png" alt="1524134192442"></p><h3 id="1-1-5-构建块-Building-Block"><a href="#1-1-5-构建块-Building-Block" class="headerlink" title="1.1.5. 构建块 Building Block"></a>1.1.5. 构建块 Building Block</h3><p>像上一小节中一个残差单元的结构，被称为一个<strong>构建块 Building Block</strong>。此外还有另一种<strong>瓶颈构建块 Bottleneck Building Block</strong>：</p><p><img src="/assets/bt6hwpv22lko3tjpwnqwcx85t1t4z110.png" alt="1524204482795"></p><p>这种构建块由三个卷积层堆叠而成，第一个和最后一个$1\times1$卷积层负责减小或恢复维度，中间的$3\times3$卷积层负责提取特征。这样的构建块通常用于更深的网络中。</p><h2 id="1-2-官方模型"><a href="#1-2-官方模型" class="headerlink" title="1.2. 官方模型"></a>1.2. 官方模型</h2><p>以下代码来自于TensorFlow官方给出的<a href="https://github.com/tensorflow/models/tree/r1.7.0/official/resnet" target="_blank" rel="noopener">ResNet实现</a>，用于训练<a href="https://www.cs.toronto.edu/~kriz/cifar.html" target="_blank" rel="noopener">CIFAR-10</a>数据集。接下来将通过全部使用<strong>默认配置</strong> 情况下，了解ResNet是如何被构建的。</p><h3 id="1-2-1-配置解释"><a href="#1-2-1-配置解释" class="headerlink" title="1.2.1. 配置解释"></a>1.2.1. 配置解释</h3><p>在默认情况下，运行<code>python cifar10_main.py</code>，使用的是如下配置：</p><ul><li><code>data_dir=/tmp/cifar10_data</code> 决定数据集的位置，这个参数对模型没有影响，不讨论。</li><li><code>model_dir=/tmp/cifar10_model</code> 决定模型存储的位置，这个参数对模型没有影响，不讨论。</li><li><code>resnet_size=32</code> 模型中卷积层的数量</li><li><code>train_epochs=250</code> 针对整个数据集的训练次数</li><li><code>epochs_between_evals=10</code> 这个参数对模型没有影响，不讨论。</li><li><code>batch_size=128</code> 每次从训练集中取出的样本数</li></ul><h4 id="卷积层的数量"><a href="#卷积层的数量" class="headerlink" title="卷积层的数量"></a>卷积层的数量</h4><p>第三个参数<code>resnet_size=32</code>表示卷积层的数量，在官方实现中，对这个数量有一个限制：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cifar10_main.py</span></span><br><span class="line"><span class="keyword">if</span> resnet_size % <span class="number">6</span> != <span class="number">2</span>:</span><br><span class="line">  <span class="keyword">raise</span> ValueError(<span class="string">'resnet_size must be 6n + 2:'</span>, resnet_size)</span><br></pre></td></tr></table></figure><p>也就是说，卷积层的数量必须是<code>6n+2</code>。为什么有这样的限制呢？</p><p>首先解释<code>6n</code>。通过阅读ResNet的论文[1]，我们可以知道，有两种构建块——普通的构建块具有两个卷积层、瓶颈构建块具有三个卷积层。</p><p>假设我们只使用具有两个卷积层的普通构建块，那么只需要要求卷积层满足<code>2n</code>即可，因为每个构建块有两个卷积层，构建块是不可分的，所以有<code>n</code>个构建块则表示有<code>2n</code>个卷积层，这很好理解。同样的道理，如果我们只使用有三个卷积层的瓶颈构建块，则要求卷积层有<code>3n</code>个。</p><p>但由于官方的ResNet同时支持使用两种构建块，为了实现这一点，就只能找<code>2n</code>和<code>3n</code>的最小公倍数——<code>6n</code>。</p><p>接着解释为什么要<code>+2</code>。通过上面的解释，可以得出一个结论：<code>6n</code>这个数量表示的是构建块中卷积层的总数。而<code>+2</code>自然得就可以看做是网络中其他部分的卷积层总数，查看源码，可以看到这两段：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># resnet_model.py</span></span><br><span class="line"><span class="comment"># 构建块之前的卷积，用于维度转换</span></span><br><span class="line">inputs = conv2d_fixed_padding(...)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建块</span></span><br><span class="line"><span class="keyword">for</span> i, num_blocks <span class="keyword">in</span> enumerate(self.block_sizes):</span><br><span class="line">num_filters = self.num_filters * (<span class="number">2</span>**i)</span><br><span class="line">inputs = block_layer(...)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建块之后的平均池化</span></span><br><span class="line"><span class="comment"># 平均池化是卷积的一种</span></span><br><span class="line">inputs = tf.layers.average_pooling2d(...)</span><br></pre></td></tr></table></figure><p>从代码可以看出，除了在构建块的前后分别有一次用于维度转换的卷积核一次平均池化（卷积的一种），这就是<code>+2</code>的来源。</p><p>因此可以得出，在这种实现中卷积层数数量一定满足<code>6n+2</code>。</p><h4 id="其他参数"><a href="#其他参数" class="headerlink" title="其他参数"></a>其他参数</h4><p>另外另个值得一提的参数是<code>train_epochs</code>和<code>batch_size</code>。前者指的是对于整个训练集，模型进行训练的次数；后者则表示，每次从训练集中取出的样本数。</p><p>可以很简单的得到一个公式，计算总的训练步数：</p><p>$$step = \frac{train_epochs\times dataset_size}{batch_size}$$</p><p>将默认数据，<code>train_epochs=250</code>、<code>batch_size=128</code>以及CIFAR-10的训练集大小<code>dataset_size=50000</code>带入可以算出，<code>step=97656.25</code>。</p><p>实际的训练情况如下：</p><p><img src="/assets/6cmtc5jpiz6no3kqr1jp3wi7prv2qo03.png" alt="1524205891688"></p><h5 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h5><p>可以通过日志看到，在GeForce GTX 1080上，训练速度大概如下（大概20step/s）：</p><p><img src="/assets/9hwfy2trad8taxsbp2dm8hfwzvphhdhu.png" alt="1524206243857"></p><p>所以总的训练时间大概是97656/20=4882秒，大概<em>一个半小时</em>。</p><h3 id="1-2-2-网络结构"><a href="#1-2-2-网络结构" class="headerlink" title="1.2.2. 网络结构"></a>1.2.2. 网络结构</h3><h4 id="1-残差结构之前"><a href="#1-残差结构之前" class="headerlink" title="1) 残差结构之前"></a>1) 残差结构之前</h4><h5 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h5><p>先搞清楚整个网络的输入。输入来自CIFAR-10的训练集，在这个实现中，图片被进行了多次预处理（包括随机剪裁、随机镜像反转、标准化等），最后形成了$3\times32\times32$的矩阵，或者写成<code>[3, 32, 32]</code>，对应<code>[channels, width, height]</code>。实现中还处理了<em>channels_last</em>和<em>channels_first</em>的问题，这里为了方便就认为所有输入图片都是<strong>channels_first</strong>。此外，每次从数据集中取出的是<code>batch_size=128</code>张图，所以实际上的输入矩阵为<code>[128, 3, 32, 32]</code>，对应<code>[batch, channels, width, height]</code>。</p><h5 id="网络中使用的卷积"><a href="#网络中使用的卷积" class="headerlink" title="网络中使用的卷积"></a>网络中使用的卷积</h5><p>网络中并不是直接使用TensorFlow的卷积实现，而是定义了一个名为<code>conv2d_fixed_padding</code>的卷积操作。逻辑如下：</p><ul><li>如果<code>strides=1</code>，则通过padding<strong>保证卷积前后size一致</strong></li><li>如果<code>strides&gt;=1</code>，则通过padding<strong>使得卷积后的特征图的size变为$\lceil  \frac{size}{strides} \rceil$</strong></li></ul><p>通过读源码可知，<em>实际上是通过padding将kernel_size的影响抵消</em>，过程比较繁琐就不写出来了。</p><p>举个简单的例子，如果输入为<code>[128, 3, 32, 32]</code>，卷积核数量为16</p><ul><li><code>strides=1</code>，输出位<code>[128, 16, 32, 32]</code>，size依旧为32*32</li><li><code>strides=3</code>，输出位<code>[128, 16, 11, 11]</code>，其中$11 = \lceil  \frac{32}{3} \rceil$</li></ul><p><strong>在之后的描述中，所有的卷积都指的是<code>conv2d_fixed_padding</code>。</strong></p><h5 id="第一次卷积"><a href="#第一次卷积" class="headerlink" title="第一次卷积"></a>第一次卷积</h5><p>来自训练集的输入<code>[128, 3, 32, 32]</code>在这里经历了第一次卷积，参数如下：</p><ul><li>strides = 1</li><li>filters = 16</li><li>kernel_size = 3</li></ul><p>这次卷积的目的主要是进行维度的转换，卷积的的结果是<code>[128, 16, 32, 32]。</code></p><h5 id="最大池化"><a href="#最大池化" class="headerlink" title="最大池化"></a>最大池化</h5><p>实现中实际上定义了最大池化的操作，但是由于默认配置下，这个操作并不会被执行，所以这里忽略它。</p><h5 id="残差层之前总结"><a href="#残差层之前总结" class="headerlink" title="残差层之前总结"></a>残差层之前总结</h5><p><img src="/assets/iq8b1ygiiffdpoocn6tih14pe1cxoo1d.png" alt="1524208974147"></p><h4 id="2-残差结构"><a href="#2-残差结构" class="headerlink" title="2) 残差结构"></a>2) 残差结构</h4><p>这是网络的重点，整个残差结构分为多个残差层，每个残差层分为多个构建块，每个构建块呢有多个卷积层，每个卷积层内有多个卷积核。下面将逐一进行介绍。</p><h5 id="残差层"><a href="#残差层" class="headerlink" title="残差层"></a>残差层</h5><p>在一个残差结构中，有多个残差层。我们采用默认配置的情况下，有三个残差层。</p><p>实际上在官方实现的ResNet中，残差层被固定为3层：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cifar10_main.py</span></span><br><span class="line">super(Cifar10Model, self).__init__(</span><br><span class="line">  ...,</span><br><span class="line">  block_sizes=[num_blocks] * <span class="number">3</span>,</span><br><span class="line">  block_strides=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这是构建模型时的代码，其中<code>block_sizes</code>和<code>block_strides</code>的长度就是残差层的数量，被固定为了3层。</p><p><img src="/assets/n1fbnyap3wcif094e3wfk0przugfw75t.png" alt="1524212942030"></p><p>每个残差层内部，特征图的维度是一致的，但是在残差层之间特征图维度不同。</p><h5 id="构建块"><a href="#构建块" class="headerlink" title="构建块"></a>构建块</h5><p>每个残差层内部有多个构建块，我们采用默认配置的情况下，每个残差层有5个构建块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cifar10_main.py</span></span><br><span class="line">num_blocks = (resnet_size - <span class="number">2</span>) // <span class="number">6</span></span><br><span class="line">super(Cifar10Model, self).__init__(</span><br><span class="line">  ...,</span><br><span class="line">  block_sizes=[num_blocks] * <span class="number">3</span>,</span><br><span class="line">  block_strides=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>同样是这段代码，其中<code>num_blocks</code>代表每一层中构建块的数量，可以看出是通过卷积层的数量<code>resnet_size</code>计算出来的。默认情况下<code>resnet_size=32</code>，所以<code>num_blocks=5</code>，每个残差层有5个构建块。</p><p><img src="/assets/6fy46t4cd4ew4tq395kd7y9lqs2g2sws.png" alt="1524213398594"></p><p>从上文我们可以知道，论文[1]中构建块共有两种实现，分别为普通构建块v1和瓶颈构建块v1，在另一篇论文[2]中，这两种构建块有不同的实现——普通构建块v2和瓶颈构建块v2。v1和v2两种实现的主要区别是：BN层是在卷积操作之前执行还是之后执行，具体可以见论文[2]。在这四中构建块中，根据默认配置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cifar10_main.py</span></span><br><span class="line">DEFAULT_VERSION = <span class="number">2</span></span><br><span class="line">super(Cifar10Model, self).__init__(</span><br><span class="line">  ...,</span><br><span class="line">  bottleneck=<span class="keyword">False</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>可以得出，使用的是<strong>普通构建块v2</strong>。</p><p><img src="/assets/5cjfcaqd6ksy6jq04vsobuo3xb657m3d.png" alt="1524215412114"></p><h5 id="卷积层和卷积核"><a href="#卷积层和卷积核" class="headerlink" title="卷积层和卷积核"></a>卷积层和卷积核</h5><p>由上图，每个构建块都由两次卷积操作构成，每次卷积操作之前都会进行BN和ReLU，最后叠加一个快捷连接的恒等映射，得出结果。也就是说，每个构建块中有两个卷积层。</p><p>第一个卷积层中的每个卷积核的参数如下：</p><ul><li>第一个残差层中：<code>strides=1</code>、<code>kernel_size=3</code>、<code>filters=16</code></li><li>第一个残差层中：<code>strides=2</code>、<code>kernel_size=3</code>、<code>filters=32</code></li><li>第一个残差层中：<code>strides=2</code>、<code>kernel_size=3</code>、<code>filters=64</code></li></ul><p>其中strides和kernel_size是在再如下代码中定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cifar10_main.py</span></span><br><span class="line">super(Cifar10Model, self).__init__(</span><br><span class="line">  ...,</span><br><span class="line">  kernel_size=<span class="number">3</span>,</span><br><span class="line">  block_strides=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>filters则通过以下代码定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cifar10_main.py</span></span><br><span class="line">super(Cifar10Model, self).__init__(</span><br><span class="line">  ...,</span><br><span class="line">  num_filters=<span class="number">16</span>,</span><br><span class="line">  block_sizes=[num_blocks] * <span class="number">3</span></span><br><span class="line">)</span><br><span class="line"><span class="comment"># resnet_model.py</span></span><br><span class="line"><span class="keyword">for</span> i, num_blocks <span class="keyword">in</span> enumerate(self.block_sizes):</span><br><span class="line">num_filters = self.num_filters * (<span class="number">2</span>**i)</span><br></pre></td></tr></table></figure><p>可以看出，在每个残差层，filters数量都会加倍。</p><p>卷积代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">inputs = conv2d_fixed_padding(</span><br><span class="line">  inputs=inputs, filters=filters, kernel_size=<span class="number">3</span>, strides=strides,</span><br><span class="line">  data_format=data_format</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>第二个卷积层中的卷积核，参数与第一层中的基本一致，唯一的区别是，所有的卷积核的<code>strides=1</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">inputs = conv2d_fixed_padding(</span><br><span class="line">  inputs=inputs, filters=filters, kernel_size=<span class="number">3</span>, strides=<span class="number">1</span>,</span><br><span class="line">  data_format=data_format</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h5 id="残差层之间的投影"><a href="#残差层之间的投影" class="headerlink" title="残差层之间的投影"></a>残差层之间的投影</h5><p>由于残差层之间，输入和输出存在维度不同的问题，所以每个残差层的第一个构建块都需要进行投影。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 投影函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">projection_shortcut</span><span class="params">(inputs)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> conv2d_fixed_padding(</span><br><span class="line">    inputs=inputs, filters=filters_out, kernel_size=<span class="number">1</span>, strides=strides,</span><br><span class="line">    data_format=data_format)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每个残差层的第一个构建块进行投影</span></span><br><span class="line">inputs = block_fn(inputs, filters, training, projection_shortcut, strides,</span><br><span class="line">                  data_format)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 其余的构建块不需要投影</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">1</span>, blocks):</span><br><span class="line">  inputs = block_fn(inputs, filters, training, <span class="keyword">None</span>, <span class="number">1</span>, data_format)</span><br></pre></td></tr></table></figure><h5 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h5><p><img src="/assets/a0yexevcccsdd5bii4a2zah9p2vwowv1.png" alt="1524241808617"></p><p>经过残差结构之后，输入和输出情况如上图。</p><h4 id="3-残差结构之后"><a href="#3-残差结构之后" class="headerlink" title="3) 残差结构之后"></a>3) 残差结构之后</h4><p>残差结构之后就是简单的BN层、ReLU层、平均池化层和全连接层：</p><p><img src="/assets/cgqw1et8j322uzvktqhm6kizq762ods0.png" alt="1524241923499"></p><h4 id="4-总体网络结构"><a href="#4-总体网络结构" class="headerlink" title="4) 总体网络结构"></a>4) 总体网络结构</h4><p><img src="/assets/xd5tie9yyp7q2hsdcmei8mcnpoiuge4t.png" alt="1524241957064"></p><h5 id="题外话-1"><a href="#题外话-1" class="headerlink" title="题外话"></a>题外话</h5><p>PPT是世界上最好用的作图工具23333，上图的PPT<a href="http://ocphk5wc7.bkt.clouddn.com/ResNet.pptx" target="_blank" rel="noopener">源文件链接</a></p><h2 id="1-3-修改官方模型"><a href="#1-3-修改官方模型" class="headerlink" title="1.3. 修改官方模型"></a>1.3. 修改官方模型</h2><p>得益于官方模型高可用的实现，对这个模型进行简单修改非常简单：</p><ul><li><p>增减卷积层/残差结构：在运行时加入参数<code>--resnet_size=m</code>，这里<code>m</code>就是卷积层的数量，必须满足<code>m % 6 == 2</code>。可以得出整个网络中构建块的数量为<code>block_num = (m - 2) // 2</code>。最终卷积层的数量实际上的与你采用什么构建块有关，如果使用普通构建块，则卷积层数量为<code>block_num * 2</code>，如果采用瓶颈构建块则为<code>block_num * 3</code>。</p></li><li><p>使用不同的构建块：默认使用的是普通构建块v2，可以通过修改<code>resnet_model.py</code>中的<code>DEFAULT_VERSION</code>使用不同的版本；通过修改<code>cifar10_main.py</code>中的<code>bottleneck=True</code>使用不同的构建块。</p></li><li><p>训练不同的数据集：网络的结构不需要过多的修改，主要修改的是<code>cifar10_main.py</code>数据输入的处理函数：</p><ul><li>get_filenames</li><li>parse_record</li><li>preprocess_image</li><li>input_fn</li><li>get_synth_input_fn</li></ul><p>以及修改一些全局变量：</p><ul><li>_NUM_CLASSES</li></ul></li></ul><h1 id="2-DeepFashion"><a href="#2-DeepFashion" class="headerlink" title="2. DeepFashion"></a>2. DeepFashion</h1><h2 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1. 简介"></a>2.1. 简介</h2><p><a href="http://mmlab.ie.cuhk.edu.hk/projects/DeepFashion.html" target="_blank" rel="noopener">DeepFashion</a>是一个关于服饰的超大规模数据集，具有以下特点：</p><ul><li>DeepFashion拥有超过800,000张时尚服饰图片，包括良好的店铺图片和消费者拍摄的不受约束的图片。</li><li>DeepFashion拥有50个分类（categories）、1000中属性（attributes）以及服饰关键点（clothing landmarks）。</li><li>DeepFashion拥有超过300,000对交叉/跨域的服饰图，例如同一个服饰来自商家和消费者的一对图片。</li></ul><p>此外，DeepFashion还有五个基准测试问题（Benchmark），包括：类别和属性预测、店铺服饰检索、消费者对店铺服饰检索、服饰关键点检测和综合测试。</p><h2 id="2-2-基准测试问题"><a href="#2-2-基准测试问题" class="headerlink" title="2.2. 基准测试问题"></a>2.2. 基准测试问题</h2><p>DeepFashion目前有五个基准测试问题：</p><ul><li><strong>类别和属性预测 Category and Attribute Prediction Benchmark</strong>，这项任务是对50个类别和1,000个属性进行分类。</li><li><strong>店铺服饰检索 In-shop Clothes Retrieval Benchmark</strong>，这个任务是确定源自店铺拍摄的两幅图片是否属于相同的服饰。</li><li><strong>消费者对店铺服饰检索 Consumer-to-shop Clothes Retrieval Benchmark</strong>，这项任务是将来自消费者图片与来自店铺的相同服饰的图片进行匹配。</li><li><strong>服饰关键点检测 Fashion Landmark Detection Benchmark</strong>，这项任务是预测服饰上关键点的位置，例如领口，下摆和袖口的位置。</li><li><strong>综合测试 Fashion Synthesis Benchmark</strong>，这项任务是利用已有的图片生成新的图片。</li></ul><h2 id="2-2-店铺服饰检索"><a href="#2-2-店铺服饰检索" class="headerlink" title="2.2. 店铺服饰检索"></a>2.2. 店铺服饰检索</h2><h3 id="2-2-1-图片"><a href="#2-2-1-图片" class="headerlink" title="2.2.1. 图片"></a>2.2.1. 图片</h3><p>In-shop Clothes Retrieval Benchmark的图片格式为：</p><ul><li>居中的256*256 JPG格式图片</li><li>原始图像的纵横比保持不变</li></ul><h3 id="2-2-2-标注"><a href="#2-2-2-标注" class="headerlink" title="2.2.2. 标注"></a>2.2.2. 标注</h3><p>In-shop Clothes Retrieval Benchmark的数据集中标注如下：</p><ul><li><p>图片中服饰的边界盒 <code>list_bbox_inshop.txt</code>，第一行为数量，第二行为列名</p><ul><li><p>图片名，如<code>img/WOMEN/Blouses_Shirts/id_00000001/02_1_front.jpg</code></p></li><li><p>服饰类型</p><p>| 值   | 意义       |<br>| —- | ———- |<br>| 1    | upper-body |<br>| 2    | lower-body |<br>| 3    | full-body  |</p></li><li><p>姿势类型</p><p>| 值   | 意义             |<br>| —- | —————- |<br>| 1    | frontal view     |<br>| 2    | side view        |<br>| 3    | back view        |<br>| 4    | zoom-out view    |<br>| 5    | zoom-in view     |<br>| 6    | stand-alone view |</p></li><li><p>边界盒位置</p><p>| 符号     | 意义              |<br>| ——– | —————– |<br>| x_1, y_1 | upper left point  |<br>| x_2, y_2 | lower right point |</p></li></ul></li><li><p>图片中服饰的关键点 <code>list_landmarks_inshop.txt</code>，第一行为数量，第二行为列名</p><ul><li><p>图片名，如<code>img/WOMEN/Blouses_Shirts/id_00000001/02_1_front.jpg</code></p></li><li><p>服饰类型</p><p>| 值   | 意义                  |<br>| —- | ——————— |<br>| 1    | upper-body，6个关键点 |<br>| 2    | lower-body，4个关键点 |<br>| 3    | full-body，8个关键点  |</p></li><li><p>变化类型</p><p>| 值   | 意义           |<br>| —- | ————– |<br>| 1    | normal pose    |<br>| 2    | medium pose    |<br>| 3    | large pose     |<br>| 4    | medium zoom-in |<br>| 5    | large zoom-in  |</p></li><li><p>关键点可见性</p><p>| 值   | 意义               |<br>| —- | —————— |<br>| 1    | visible            |<br>| 2    | invisible/occluded |<br>| 3    | truncated/cut-off  |</p></li><li><p>关键点</p><p>| 服饰类型 | 数量 | 意义                                                         |<br>| ——– | —- | ———————————————————— |<br>| 1        | 6    | left collar, right collar, left sleeve, right sleeve, left hem, right hem |<br>| 2        | 4    | left waistline, right waistline, left hem, right hem         |<br>| 3        | 8    | left collar, right collar, left sleeve, right sleeve, left waistline, right waistline, left hem, right hem |</p></li></ul></li><li><p>服饰ID集合 <code>list_item_inshop.txt</code>，第一行为数量</p><ul><li>ID，如<code>id_00000001</code></li></ul></li><li><p>服饰描述 <code>list_description_inshop.json</code></p><ul><li>ID，如<code>id_00000001</code></li><li>颜色，如<code>Cream</code></li><li>描述，如<code>Style Deals - When temps start to rise...</code></li></ul></li><li><p>属性集合 <code>list_attr_cloth.txt</code> 第一行位属性数量，第二行为列名</p><ul><li>属性名，如<code>lightweight</code></li></ul></li><li><p>服饰属性 <code>list_attr_items.txt</code></p><ul><li><p>还有若干个值，数量等于属性集合中属性的数量</p><p>| 值   | 意义               |<br>| —- | —————— |<br>| 1    | 服饰有对应的属性   |<br>| 2    | 服饰没有对应的属性 |</p></li></ul></li><li><p>映射关系 <code>list_eval_partition.txt</code>，第一行为数量，第二行为列名</p><ul><li><p>图片名，如<code>img/WOMEN/Dresses/id_00000002/02_1_front.jpg</code></p></li><li><p>物品ID，如<code>id_00000002</code></p></li><li><p>状态</p><p>| 值      | 意义           |<br>| ——- | ————– |<br>| train   | training image |<br>| query   | query image    |<br>| gallery | gallery image  |</p></li></ul></li><li><p>图片中服饰的颜色 <code>list_color_cloth.txt</code>，第一行为数量，第二行为列名</p><ul><li>图片名，如<code>img/WOMEN/Blouses_Shirts/id_00000001/02_1_front.jpg</code></li><li>颜色，如<code>Cream</code></li></ul></li></ul><h3 id="2-2-3-对标注的理解"><a href="#2-2-3-对标注的理解" class="headerlink" title="2.2.3. 对标注的理解"></a>2.2.3. 对标注的理解</h3><p><img src="/assets/71mles4nstnu2i1vxtf6g33uo8ivcxre.png" alt="1524298234121"></p><h1 id="3-参考"><a href="#3-参考" class="headerlink" title="3. 参考"></a>3. 参考</h1><p><a href="https://arxiv.org/abs/1512.03385" target="_blank" rel="noopener">[1]Deep Residual Learning for Image Recognition</a></p><p><a href="https://arxiv.org/abs/1603.05027" target="_blank" rel="noopener">[2]Identity Mappings in Deep Residual Networks</a></p><p><a href="https://www.zhihu.com/question/53224378/answer/159102095" target="_blank" rel="noopener">[3]知乎|theone的回答</a></p><p><a href="https://www.cv-foundation.org/openaccess/content_cvpr_2016/papers/Liu_DeepFashion_Powering_Robust_CVPR_2016_paper.pdf" target="_blank" rel="noopener">[4]DeepFashion: Powering Robust Clothes Recognition and Retrieval with Rich Annotations</a></p><p><a href="http://mmlab.ie.cuhk.edu.hk/projects/DeepFashion/liuYLWTeccv16.pdf" target="_blank" rel="noopener">[5]Fashion Landmark Detection in the Wild</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近主要按照师兄的指导，读论文了解ResNet，读TensorFlow官方的ResNet实现，简单修改网络以及了解DeepFashion数据集。&lt;/p&gt;
    
    </summary>
    
      <category term="Homework" scheme="http://blog.andiedie.cn/categories/Homework/"/>
    
    
  </entry>
  
  <entry>
    <title>SyncMyCookie 中文文档</title>
    <link href="http://blog.andiedie.cn/posts/abbd/"/>
    <id>http://blog.andiedie.cn/posts/abbd/</id>
    <published>2018-04-10T01:26:42.000Z</published>
    <updated>2019-01-23T07:41:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="SyncMyCookie"><a href="#SyncMyCookie" class="headerlink" title="SyncMyCookie"></a>SyncMyCookie</h1><p><a href="https://github.com/Andiedie/sync-my-cookie/blob/master/README.md" target="_blank" rel="noopener">English</a> | <a href="https://blog.andiedie.cn/posts/abbd/">中文</a></p><p>SyncMyCookie 是一个可以在多个浏览器间同步Cookie的插件。</p><p>你可以使用它同步任意网站的 cookies。你还可以通过配置自定义 <code>Auto Merge</code> 和 <code>Auto Push</code> 的规则。</p><a id="more"></a><h1 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h1><ul><li><p>推荐：<a href="https://chrome.google.com/webstore/detail/syncmycookie/laapobniolmbhnkldepjnebendehhmmf" target="_blank" rel="noopener">Chrome Web Store</a></p></li><li><p><a href="https://github.com/andiedie/sync-my-cookie/releases/download/v2.0.0/crx.zip" target="_blank" rel="noopener">SyncMyCookie.crx</a></p></li><li><p><a href="https://github.com/andiedie/sync-my-cookie/releases/download/v2.0.0/pre-built.zip" target="_blank" rel="noopener">预编译</a></p><p>在 Chrome 扩展（<code>chrome://extensions</code>）中启动开发者模式并通过<code>加载未打包的拓展</code>安装。</p></li><li><p>从源码编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/Andiedie/sync-my-cookie.git</span><br><span class="line"><span class="built_in">cd</span> sync-my-cookie</span><br><span class="line">yarn            <span class="comment"># npm install</span></span><br><span class="line">yarn build      <span class="comment"># npm run build</span></span><br></pre></td></tr></table></figure><p>像上面一样加载<code>build</code>目录即可。</p></li></ul><h1 id="2-使用场景"><a href="#2-使用场景" class="headerlink" title="2. 使用场景"></a>2. 使用场景</h1><h2 id="2-1-避免频繁登录"><a href="#2-1-避免频繁登录" class="headerlink" title="2.1. 避免频繁登录"></a>2.1. 避免频繁登录</h2><p>有些网站设置的 cookies 是 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#Session_cookies" target="_blank" rel="noopener">session</a> 级别的，一旦浏览器关闭，这些 cookies 就会过期失效，这使得我们需要频繁地进行登录。</p><p>你可以在登录有使用 SyncMyCookie 保存这些 cookies，并启动 <code>Auto Merge</code> 功能。这样即使浏览器关闭了，你的登录状态也不会失效。</p><h2 id="2-2-共享账号"><a href="#2-2-共享账号" class="headerlink" title="2.2. 共享账号"></a>2.2. 共享账号</h2><p>也许你会有这样的需求：</p><ul><li>与朋友共享账号</li><li>突破单点登录的限制</li><li>在多个浏览器间同步登录状态</li></ul><p>使用 SyncMyCookie 能非常简单的满足这些需求。</p><p>你只需要在登录后使用 SyncMyCookie 保存网站的 cookies，并启动 <code>Auto Push</code> 功能；在其他的浏览器上，启用 <code>Auto Merge</code> 功能。这样你的登录状态就可以在多个浏览器间自动同步。</p><h1 id="3-配置"><a href="#3-配置" class="headerlink" title="3. 配置"></a>3. 配置</h1><p>为了能在设备间同步 cookies，插件将你的 cookies 加密存储在 GitHub Gist 中，这就要求你有一个 GitHub 账号。</p><p>如果发现了一些更好的存储方案，请在<a href="https://github.com/Andiedie/sync-my-cookie/issues" target="_blank" rel="noopener">这里</a>提交 issue 告诉我，十分感谢。</p><h2 id="3-1-生成-GitHub-Access-Token"><a href="#3-1-生成-GitHub-Access-Token" class="headerlink" title="3.1. 生成 GitHub Access Token"></a>3.1. 生成 GitHub Access Token</h2><p>GitHub Access Token（以下简称 <strong>token</strong>）的作用是让插件有权限修改你的 Gist。你可以在<a href="https://github.com/settings/tokens/new" target="_blank" rel="noopener">这里</a>生成一个新的 token。</p><p>注意：</p><p><img src="/assets/94211156.jpg" alt=""></p><p><strong>插件只需要 Gist 权限</strong>，所以请不要勾选其他不必要的权限，以保证你的账号安全。</p><h2 id="3-2-配置插件"><a href="#3-2-配置插件" class="headerlink" title="3.2. 配置插件"></a>3.2. 配置插件</h2><p><img src="/assets/right_click.jpg" alt="right_click"></p><p>右键插件，点击选项。</p><p><img src="/assets/options.jpg" alt="options"></p><p>输入你的 token 和加密密钥。</p><p>请注意：忽略可选的 Gist ID 和 Filename 字段之后，插件会创建一个全新的 Gist 来存储数据。如果你想要在两个浏览器间同步 cookies，那么两个浏览器上的插件必须拥有相同的配置，即 <code>GitHub Access Token</code>、<code>password</code>、<code>Gist ID</code> 和 <code>Filename</code> 这四个字段必须完全相同。插件提供了导入导出配置的功能帮助你完成这项工作。</p><h1 id="4-使用"><a href="#4-使用" class="headerlink" title="4. 使用"></a>4. 使用</h1><h2 id="4-1-Push-cookies"><a href="#4-1-Push-cookies" class="headerlink" title="4.1. Push cookies"></a>4.1. Push cookies</h2><p>将指定网站 cookies 加密保存到 Gist 中，只需要在浏览该网站时点开插件，点击 <code>Push</code> 即可。</p><p><img src="/assets/push.jpg" alt="push"></p><h2 id="4-2-Merge-cookeis"><a href="#4-2-Merge-cookeis" class="headerlink" title="4.2. Merge cookeis"></a>4.2. Merge cookeis</h2><p>要使用以保存的 cookies，在插件上选择对应的网站并点击 <code>Merge</code> 即可。</p><p><img src="/assets/merge.jpg" alt="merge"></p><h2 id="4-3-Auto-Merge"><a href="#4-3-Auto-Merge" class="headerlink" title="4.3. Auto Merge"></a>4.3. Auto Merge</h2><p>当指定网站开启 <code>Auto Merge</code> 后，每当打开浏览器，插件都会自动将指定的 cookies 合并进浏览器。</p><p><img src="/assets/auto_merge.jpg" alt="auto_merge"></p><p>自动合并后，插件上会有标徽展示本次自动合并的网站数量：<img src="/assets/auto_merge_badge.jpg" alt="auto_merge_badge"></p><h2 id="4-4-Auto-Push"><a href="#4-4-Auto-Push" class="headerlink" title="4.4. Auto Push"></a>4.4. Auto Push</h2><p>当指定网站开启 <code>Auto Push</code> 后，每当该网站的 cookies 发生变化，插件都会自动推送新的 cookies。</p><p><img src="/assets/auto_push.jpg" alt="auto_push"></p><p>自动推送后，插件上会有标徽展示本次自动推送的网站数量：<img src="/assets/auto_push_badge.jpg" alt="auto_push_badge"></p><h3 id="配置-Auto-Push"><a href="#配置-Auto-Push" class="headerlink" title="配置 Auto Push"></a>配置 Auto Push</h3><p>通常，cookies 中只有部分值是比较重要的。通过配置，<code>Auto Push</code> 功能可以在指定的值发生变化后才进行自动推送。</p><p>将鼠标悬停在 <code>Push</code> 图标上，点击出现的配置按钮：</p><p><img src="/assets/config_auto_push_entry.jpg" alt="config_auto_push_entry"></p><p>选择或输入名称，表明当这些名称的 cookies 变化时，进行推送。</p><p><img src="/assets/config_auto_push.jpg" alt="config_auto_push"></p><h1 id="5-安全"><a href="#5-安全" class="headerlink" title="5. 安全"></a>5. 安全</h1><p>由于 cookies 是你非常重要的安全凭证，所以请非常小心地使用这个插件。</p><p>插件使用 <code>HTTPS</code> 和 <code>AES-128-CBC</code> 保证在传输和存储过程中，你的 Cookie 是安全的，但你仍然需要注意如下几点：</p><ul><li>因此为了保证你的 cookies 安全，请不要随意透露你的配置，特别是密码。一旦配置泄露，你的 cookies 也随之泄露。</li><li>插件保证只会使用 GitHub Access Token 的 Gist 权限。为了防止潜在的安全问题，在生成 token 时，请只给与 Gist 权限。</li><li>理论上，多个设备使用相同的 Cookie 可以实现同时使用一些服务，但是这和服务提供商的检测机制有关。因此使用这个插件进行账号共享，风险是<strong>不确定</strong>的。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;SyncMyCookie&quot;&gt;&lt;a href=&quot;#SyncMyCookie&quot; class=&quot;headerlink&quot; title=&quot;SyncMyCookie&quot;&gt;&lt;/a&gt;SyncMyCookie&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/Andiedie/sync-my-cookie/blob/master/README.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;English&lt;/a&gt; | &lt;a href=&quot;https://blog.andiedie.cn/posts/abbd/&quot;&gt;中文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;SyncMyCookie 是一个可以在多个浏览器间同步Cookie的插件。&lt;/p&gt;
&lt;p&gt;你可以使用它同步任意网站的 cookies。你还可以通过配置自定义 &lt;code&gt;Auto Merge&lt;/code&gt; 和 &lt;code&gt;Auto Push&lt;/code&gt; 的规则。&lt;/p&gt;
    
    </summary>
    
      <category term="Development" scheme="http://blog.andiedie.cn/categories/Development/"/>
    
    
  </entry>
  
  <entry>
    <title>使用Travis进行持续集成</title>
    <link href="http://blog.andiedie.cn/posts/53ad/"/>
    <id>http://blog.andiedie.cn/posts/53ad/</id>
    <published>2018-04-04T03:19:51.000Z</published>
    <updated>2019-05-10T13:08:07.545Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-持续集成"><a href="#1-持续集成" class="headerlink" title="1. 持续集成"></a>1. 持续集成</h1><h2 id="1-1-持续集成的概念"><a href="#1-1-持续集成的概念" class="headerlink" title="1.1. 持续集成的概念"></a>1.1. 持续集成的概念</h2><blockquote><p>Continuous Integration is a software development practice where members of a team integrate their work frequently, usually each person integrates at least daily - leading to multiple integrations per day. Each integration is verified by an automated build (including test) to detect integration errors as quickly as possible. Many teams find that this approach leads to significantly reduced integration problems and allows a team to develop cohesive software more rapidly. ——Martin Fowler</p></blockquote><p>Martin Fowler关于持续集成的完整文章，可以从<a href="https://www.martinfowler.com/articles/continuousIntegration.html" target="_blank" rel="noopener">这里</a>获取。</p><a id="more"></a><h2 id="1-2-持续集成的要素"><a href="#1-2-持续集成的要素" class="headerlink" title="1.2. 持续集成的要素"></a>1.2. 持续集成的要素</h2><ol><li>统一的代码库</li><li>自动构建</li><li>自动测试</li><li>每次代码提交后都会触发一次构建</li><li>可以很容易地获取最新可执行的程序</li><li>自动化部署</li></ol><p>现在使用<a href="https://travis-ci.org/" target="_blank" rel="noopener">Travis CI</a>我们可以很容易的实现持续集成。</p><h1 id="2-使用Travis-CI-实现自动测试"><a href="#2-使用Travis-CI-实现自动测试" class="headerlink" title="2. 使用Travis CI 实现自动测试"></a>2. 使用Travis CI 实现自动测试</h1><p><strong>Travis CI</strong>是在软件开发领域中的一个在线的，分布式的持续集成服务，用来构建及测试在GitHub托管的代码。Travis只能在GitHub项目上使用，只要项目有改动，Travis就会为其提供一个运行环境，执行测试、构建甚至部署任务。下面将演示如何配置Node.js项目的自动测试。</p><h2 id="2-1-为项目开启Travis"><a href="#2-1-为项目开启Travis" class="headerlink" title="2.1. 为项目开启Travis"></a>2.1. 为项目开启Travis</h2><p>进入<a href="https://travis-ci.org" target="_blank" rel="noopener">Travis</a>，使用GItHub账号登录，点击右上角的头像，进入Profile。选择项目，打开开关即可。</p><p><img src="/assets/92417939.jpg" alt=""></p><h2 id="2-2-基本配置"><a href="#2-2-基本配置" class="headerlink" title="2.2. 基本配置"></a>2.2. 基本配置</h2><p>点击项目名和开关之间的齿轮可以进入设置页，在这里你可以进行相关的配置，不过大多数情况下<strong>保持默认</strong>即可。</p><h3 id="2-2-1-基础设置"><a href="#2-2-1-基础设置" class="headerlink" title="2.2.1. 基础设置"></a>2.2.1. 基础设置</h3><p><img src="/assets/3870977.jpg" alt=""></p><p>建议打开<strong>Build only if .travis.yml is present</strong>可以避免在没有配置文件的时候进行无意义的构建工作。此外也可以配置是否对分支、PR进行构建，并限制并行数量。</p><h3 id="2-2-2-自动取消"><a href="#2-2-2-自动取消" class="headerlink" title="2.2.2. 自动取消"></a>2.2.2. 自动取消</h3><p><img src="/assets/7491701.jpg" alt=""></p><p>建议开启，开启后如果队列中积压了大量的构建任务（比如一次性提交了大量的commit），那么Travis只会对最新的commit进行构建，避免过长的等待时间。要注意的是，自动取消只会对等待中的任务生效，也就是说，如果你的任务正在运行，那么即使有更新的任务出现，当前任务也不会被取消。</p><h3 id="2-2-3-环境变量与计划任务"><a href="#2-2-3-环境变量与计划任务" class="headerlink" title="2.2.3. 环境变量与计划任务"></a>2.2.3. 环境变量与计划任务</h3><p>在这里你可以定义任务中可以随时使用的环境变量，在本文的后续内容中也会有环境变量的简单使用。</p><p>此外，你还可以设置计划任务，让Travis定时对你的项目进行测试和构建。</p><h2 id="2-3-编写-travis-yml"><a href="#2-3-编写-travis-yml" class="headerlink" title="2.3. 编写.travis.yml"></a>2.3. 编写<code>.travis.yml</code></h2><p>首先假设你的node.js项目已经编写完成，并且可以通过<code>npm test</code>运行测试命令。</p><p>在项目根目录，创建文件<code>.travis.yml</code></p><figure class="highlight yaml"><figcaption><span>.travis.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"><span class="attr">node_js:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">'9'</span></span><br><span class="line"><span class="attr">install:</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line"><span class="attr">script:</span> <span class="string">npm</span> <span class="string">test</span></span><br></pre></td></tr></table></figure><p>这个配置文件描述了Travis将如何工作。首先我们将语言选定为了<code>node.js</code>并指定node.js的版本号为9.x.x，当然你可以指定多个版本号，Travis将在每个版本中都对你的代码进行构建和测试。</p><p>此外我们还定义了两个过程：<code>install</code>和<code>script</code>，它们分别告诉了Travis如何安装依赖，如何进行测试。</p><p>将这个文件推上GitHub，登录Travis，你会发现它正在自动的为你的项目进行构建、下载依赖并进行测试。如果测试通过，测试结果在GitHub的上有相应的标注。</p><p>至此，我们就利用Travis完成了自动测试，你在项目中的每一次改动，包括<code>commit</code>、<code>branch</code>和<code>pull request</code>，Travis都会按照.<code>travis.yml</code>的配置进行测试。</p><p><img src="/assets/44179147.jpg" alt=""></p><h2 id="2-4-生命周期"><a href="#2-4-生命周期" class="headerlink" title="2.4. 生命周期"></a>2.4. 生命周期</h2><p>除了上述的<code>install</code>和<code>script</code>，Travis还提供了大量的钩子函数</p><ul><li>install：依赖安装</li><li>script：测试（如果install失败则不运行）</li><li>deploy：部署（如果script失败则不运行）</li></ul><ul><li>before_install：install之前运行</li><li>before_script：script之前运行</li><li>after_failure：script失败后运行</li><li>after_success：script成功后运行</li><li>before_deploy：deploy之前运行</li><li>after_deploy：deploy之后运行</li><li>after_script：在整个过程的最后执行</li></ul><p>完整的构建生命周期如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">before_install</span><br><span class="line">install</span><br><span class="line">before_script</span><br><span class="line">script</span><br><span class="line">after_success or after_failure</span><br><span class="line">before_deploy</span><br><span class="line">deploy</span><br><span class="line">after_deploy</span><br><span class="line">after_script</span><br></pre></td></tr></table></figure><p>生命周期中的每一个钩子函数都可以定义多个脚本，例如</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">install:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">command1</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">command2</span></span><br></pre></td></tr></table></figure><p>此时当执行到<code>install</code>阶段时，<code>install</code>中的每一个命令都会被执行。且即使<code>command1</code>失败了，<code>command2</code>也会被执行。如果希望<code>command1</code>失败后不执行<code>command2</code>，可以用以下方法：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">install:</span> <span class="string">command1</span> <span class="string">&amp;&amp;</span> <span class="string">command2</span></span><br></pre></td></tr></table></figure><h1 id="3-使用Travis-CI-实现自动部署"><a href="#3-使用Travis-CI-实现自动部署" class="headerlink" title="3. 使用Travis CI 实现自动部署"></a>3. 使用Travis CI 实现自动部署</h1><p>自动测试完成后，我们希望将测试通过的版本自动部署到服务器上。基本的思路是，让Travis登录服务器，并在服务器上运行部署脚本。</p><h2 id="3-1-Travis登录服务器"><a href="#3-1-Travis登录服务器" class="headerlink" title="3.1. Travis登录服务器"></a>3.1. Travis登录服务器</h2><p>假设服务器地址是1.2.3.4。最简单的方法就是使用SSH Key登录。</p><h3 id="3-1-1-生成SSH-Key"><a href="#3-1-1-生成SSH-Key" class="headerlink" title="3.1.1. 生成SSH Key"></a>3.1.1. 生成SSH Key</h3><p>具体可见<a href="/2017/11/17/通过SSH-Key登录Linux/">通过SSH Key登录Linux</a>，这里只展示简单的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成key和key.pub两个文件</span></span><br><span class="line">ssh-keygen -f key</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将公钥上传到服务器</span></span><br><span class="line">ssh-copy-id -i key.pub user@1.2.3.4</span><br></pre></td></tr></table></figure><h3 id="3-1-2-配置"><a href="#3-1-2-配置" class="headerlink" title="3.1.2. 配置"></a>3.1.2. 配置</h3><p>将当前目录下的<code>key</code>文件复制到项目根目录中</p><figure class="highlight yaml"><figcaption><span>.travis.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"><span class="attr">node_js:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">'9'</span></span><br><span class="line"><span class="attr">addons:</span></span><br><span class="line"><span class="attr">ssh_known_hosts:</span> <span class="number">1.2</span><span class="number">.3</span><span class="number">.4</span></span><br><span class="line"></span><br><span class="line"><span class="attr">install:</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line"><span class="attr">script:</span> <span class="string">npm</span> <span class="string">test</span></span><br><span class="line"></span><br><span class="line"><span class="attr">before_deploy:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">eval</span> <span class="string">"$(ssh-agent -s)"</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">chmod</span> <span class="number">600</span> <span class="string">key</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">ssh-add</span> <span class="string">key</span></span><br><span class="line"></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">provider:</span> <span class="string">script</span></span><br><span class="line"><span class="attr">script:</span> <span class="string">ssh</span> <span class="bullet">-i</span> <span class="string">key</span> <span class="string">user@1.2.3.4</span></span><br></pre></td></tr></table></figure><p>这样我们就可以让Travis登录上我们的服务器，但是如果项目是在GitHub上开源的，那么相当于登录服务器的私钥也公开了，这当然是不可接受的。因此，我们将使用一种更加安全的方法。</p><h2 id="3-2-更加安全地登录服务器"><a href="#3-2-更加安全地登录服务器" class="headerlink" title="3.2. 更加安全地登录服务器"></a>3.2. 更加安全地登录服务器</h2><p>为了避免私钥公开，我们可以使用Travis的加密方法对私钥进行加密。</p><h3 id="3-2-1-下载Travis命令行工具"><a href="#3-2-1-下载Travis命令行工具" class="headerlink" title="3.2.1. 下载Travis命令行工具"></a>3.2.1. 下载Travis命令行工具</h3><p>查看<a href="https://github.com/travis-ci/travis.rb#installation" target="_blank" rel="noopener">这里</a>了解如何安装Travis，由于Windows环境比较复杂，推荐使用linux环境，Windows用户可以使用WSL（WSL相关教程见<a href="2018/03/26/WSL安装与SSH配置/">WSL安装与SSH配置</a>）。</p><p>运行下列命令安装Travis CLI</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装ruby</span></span><br><span class="line">sudo apt install ruby ruby-dev</span><br><span class="line"><span class="comment"># 安装travis</span></span><br><span class="line">gem install travis -v 1.8.8 --no-rdoc --no-ri</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line">travis version</span><br><span class="line"><span class="comment"># &gt; 1.8.8</span></span><br></pre></td></tr></table></figure><h3 id="3-2-2-登录Travis"><a href="#3-2-2-登录Travis" class="headerlink" title="3.2.2. 登录Travis"></a>3.2.2. 登录Travis</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 登录Travis</span></span><br><span class="line">travis login</span><br><span class="line"><span class="comment"># 确认登录</span></span><br><span class="line">travis whoami</span><br><span class="line"><span class="comment"># &gt; You are xxx</span></span><br></pre></td></tr></table></figure><h3 id="3-2-3-加密私钥文件"><a href="#3-2-3-加密私钥文件" class="headerlink" title="3.2.3. 加密私钥文件"></a>3.2.3. 加密私钥文件</h3><p>现在我们假设私钥文件<code>key</code>和<code>.travis.yml</code>都处于项目根目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cd到key所在的目录（比如项目根目录）</span></span><br><span class="line"><span class="built_in">cd</span> path/to/key</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加密文件</span></span><br><span class="line">travis encrypt-file key --add</span><br></pre></td></tr></table></figure><p>加密完后，当前目录下会增加一个<code>key.enc</code>文件，即<code>key</code>加密后的文件。请注意，不要将<code>key</code>上传到GitHub，取而代之的是<code>key.enc</code>。</p><p>另外进入Travis网站中，项目的设置页面，可以看到新增的环境变量</p><p><img src="/assets/64635121.jpg" alt=""></p><p>并且<code>.travis.yml</code>中会增加一行这样的配置</p><figure class="highlight yaml"><figcaption><span>.travis.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">before_install:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">openssl</span> <span class="string">aes-256-cbc</span> <span class="bullet">-K</span> <span class="string">$encrypted_57510f08f3ae_key</span> <span class="bullet">-iv</span> <span class="string">$encrypted_57510f08f3ae_iv</span></span><br></pre></td></tr></table></figure><p>这里<code>$xxxx</code>就是引用了环境变量，并使用openssl对私钥文件进行解密。</p><h3 id="3-3-travis-yml配置"><a href="#3-3-travis-yml配置" class="headerlink" title="3.3. .travis.yml配置"></a>3.3. <code>.travis.yml</code>配置</h3><figure class="highlight yaml"><figcaption><span>.travis.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"><span class="attr">node_js:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">'9'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">install:</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line"></span><br><span class="line"><span class="attr">script:</span> <span class="string">npm</span> <span class="string">test</span></span><br><span class="line"></span><br><span class="line"><span class="attr">addons:</span></span><br><span class="line"><span class="attr">  ssh_known_hosts:</span> <span class="number">119.29</span><span class="number">.252</span><span class="number">.110</span></span><br><span class="line"></span><br><span class="line"><span class="attr">before_deploy:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">openssl</span> <span class="string">aes-256-cbc</span> <span class="bullet">-K</span> <span class="string">$encrypted_57510f08f3ae_key</span> <span class="bullet">-iv</span> <span class="string">$encrypted_57510f08f3ae_iv</span></span><br><span class="line"><span class="bullet">  -</span><span class="string">in</span> <span class="string">deploy_rsa.enc</span> <span class="bullet">-out</span> <span class="string">deploy_rsa</span> <span class="bullet">-d</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">eval</span> <span class="string">"$(ssh-agent -s)"</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">chmod</span> <span class="number">600</span> <span class="string">key</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">ssh-add</span> <span class="string">key</span></span><br><span class="line"></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  provider:</span> <span class="string">script</span></span><br><span class="line"><span class="attr">  script:</span> <span class="string">bash</span> <span class="string">deploy.sh</span></span><br><span class="line"><span class="attr">  skip_cleanup:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  on:</span></span><br><span class="line"><span class="attr">    branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>注意到这里我们新增了几行：</p><ul><li><code>before_deploy</code>中的第一个命令是用于解密私钥文件<code>key</code></li><li><code>skip_cleanup</code>是为了避免部署阶段一些文件被清除，具体可以参阅官方文档</li><li><code>on branch master</code>这里是指定了只有master分支上的改动才需要进行部署</li><li><code>bash deploy.sh</code>请见下一节</li></ul><h2 id="3-4-编写部署脚本"><a href="#3-4-编写部署脚本" class="headerlink" title="3.4. 编写部署脚本"></a>3.4. 编写部署脚本</h2><p>为了便于管理，我们让deploy阶段运行我们的部署脚本<code>deploy.sh</code>，那么该如何编写这个脚本呢？</p><p>非常简单：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ssh -i key user@1.2.3.4 &lt;&lt; eeooff</span><br><span class="line"></span><br><span class="line">command1</span><br><span class="line">command2</span><br><span class="line"></span><br><span class="line">eeooff</span><br></pre></td></tr></table></figure><p>按照上面的格式，将需要再服务端上运行的命令放在两个<code>eeooff</code>中间即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-持续集成&quot;&gt;&lt;a href=&quot;#1-持续集成&quot; class=&quot;headerlink&quot; title=&quot;1. 持续集成&quot;&gt;&lt;/a&gt;1. 持续集成&lt;/h1&gt;&lt;h2 id=&quot;1-1-持续集成的概念&quot;&gt;&lt;a href=&quot;#1-1-持续集成的概念&quot; class=&quot;headerlink&quot; title=&quot;1.1. 持续集成的概念&quot;&gt;&lt;/a&gt;1.1. 持续集成的概念&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Continuous Integration is a software development practice where members of a team integrate their work frequently, usually each person integrates at least daily - leading to multiple integrations per day. Each integration is verified by an automated build (including test) to detect integration errors as quickly as possible. Many teams find that this approach leads to significantly reduced integration problems and allows a team to develop cohesive software more rapidly. ——Martin Fowler&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Martin Fowler关于持续集成的完整文章，可以从&lt;a href=&quot;https://www.martinfowler.com/articles/continuousIntegration.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;获取。&lt;/p&gt;
    
    </summary>
    
      <category term="Homework" scheme="http://blog.andiedie.cn/categories/Homework/"/>
    
    
  </entry>
  
  <entry>
    <title>实训报告 1st</title>
    <link href="http://blog.andiedie.cn/posts/c31d/"/>
    <id>http://blog.andiedie.cn/posts/c31d/</id>
    <published>2018-03-29T00:47:53.000Z</published>
    <updated>2019-05-10T13:08:07.546Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近主要通过阅读论文的方式，学习了卷积神经网络的基本概念、结构、方法。这篇周报主要是对所学知识的一些总结。</p><p>如果有错误，烦请在评论区指正。</p><a id="more"></a><h1 id="1-神经网络"><a href="#1-神经网络" class="headerlink" title="1. 神经网络"></a>1. 神经网络</h1><h2 id="1-1-神经元-Neuron"><a href="#1-1-神经元-Neuron" class="headerlink" title="1.1. 神经元 Neuron"></a>1.1. 神经元 Neuron</h2><p>神经网络由神经元组成，单个神经元的结构如下</p><p><img src="/assets/46342155.jpg" alt=""></p><p>实际上是，输入向量$x$经过权值$W$进行线性变换之后得到$W^Tx+b$，再进过激活函数$f$将线性结果转变为非线性的结果$f(W^Tx+b)$，即 $H_{W,b}=f(W^Tx+b)$，其中$W^T$是$W$的转置。</p><h3 id="1-1-1-神经元与神经细胞"><a href="#1-1-1-神经元与神经细胞" class="headerlink" title="1.1.1. 神经元与神经细胞"></a>1.1.1. 神经元与神经细胞</h3><p>为了方便，我将用<strong>神经元</strong>来表示本文中神经网络的基本单位，而用<strong>神经细胞</strong>表示生物学中的概念。</p><p>让我们来将这个神经元与神经细胞做对比。</p><p><img src="/assets/9170400.jpg" alt=""></p><p>神经细胞有<strong>树突</strong>、<strong>细胞体</strong>和<strong>轴突</strong>。单个神经细胞可以看做一个二元分类器————兴奋时输出<code>1</code>，抑制时输出<code>0</code>。当信号量超过某个阈值时，神经元可以将兴奋沿着轴突传递给神经元。</p><p>而这里的神经元则是为了模拟神经细胞，权值向量$W$对应树突，偏置$b$对应阈值，激活函数$f$对应细胞体。神经元通过权值向量$W$接收来自上一次的输入向量$x$，并将输入$W^Tx+b$交给激活函数$f$。激活函数将决定传递给下一层神经元的输出。</p><h3 id="1-1-2-激活函数-Activation-Function"><a href="#1-1-2-激活函数-Activation-Function" class="headerlink" title="1.1.2. 激活函数 Activation Function"></a>1.1.2. 激活函数 Activation Function</h3><p>激活函数定义了神经元在线性变换$W^Tx+b$之后的非线性输出结果。</p><h4 id="为什么使用激活函数"><a href="#为什么使用激活函数" class="headerlink" title="为什么使用激活函数"></a>为什么使用激活函数</h4><p>如果不使用激活函数，由于所有的操作都是线性的，所以整个神经网络只是一个线性回归模型。线性回归模型的表达能力有限，它在很多问题上都表现得不够好，甚至无法解决这些问题。因此我们通过引入激活函数，为神经网络引入非线性的因素，增强它的能力，使其可以学习更加复杂的数据，表达输入输出之间非线性的复杂映射关系。</p><h4 id="常用的激活函数有"><a href="#常用的激活函数有" class="headerlink" title="常用的激活函数有"></a>常用的激活函数有</h4><ul><li>Sigmoid：$S(t)=\frac{1}{1+e^{-t}}$</li><li>Tanh: $tanh(x)=\frac{sinh(x)}{cosh(x)}=\frac{e^x-e^{-x}}{e^x+e^{-x}}$</li><li>ReLU：$f(x)=max(0,x)$</li></ul><p>由于梯度消失问题(Vanishing Gradient Problem)，前两者已经弃用，ReLU是主流的激活函数。</p><h3 id="1-1-3-全连接-Fully-Connected"><a href="#1-1-3-全连接-Fully-Connected" class="headerlink" title="1.1.3. 全连接 Fully-Connected"></a>1.1.3. 全连接 Fully-Connected</h3><p>这里我们展示的神经元，将来自输入向量$x$中的所有数据都用于计算，我们还称这个神经元是<strong>全连接的(fully-connected)</strong>。</p><p>继续我们神经元与神经细胞的比较联想，假如这个神经元是输入向量之后的第一层神经元，那么你可以想象成，我们脑中有一个树突极其巨大的神经细胞，它将来自外界的刺激全部收入囊中，并根据刺激给出输出。</p><p>全连通的好处显而易见，每个神经元都可以获取最全面的输入；但它的缺点也显而易见————我们定义处理大量的权值参数。这个缺点的具体描述，以及全连通缺点的方法，都会在接下来的内容中提到。</p><h2 id="1-2-多层神经网络"><a href="#1-2-多层神经网络" class="headerlink" title="1.2. 多层神经网络"></a>1.2. 多层神经网络</h2><p>当多个神经元组合起来，形成分层结构时，就形成了神经网络。</p><p><img src="/assets/28640822.jpg" alt=""></p><p>其中</p><p>$a_1^{(2)}=f(W^{(1)}_{11}x_1+W^{(1)}_{12}x_2+W^{(1)}_{13}x_3+b^{(1)}_1)$</p><p>$a_2^{(2)}=f(W^{(1)}_{21}x_1+W^{(1)}_{22}x_2+W^{(1)}_{23}x_3+b^{(1)}_2)$</p><p>$a_3^{(2)}=f(W^{(1)}_{31}x_1+W^{(1)}_{32}x_2+W^{(1)}_{33}x_3+b^{(1)}_3)$</p><p>$H_{W,b}=f(W^{(2)}_{12}a_1^{(2)}+W^{(2)}_{22}a_2^{(2)}+W^{(2)}_{32}a_3^{(2)}+b^{(2)}_1)$</p><p>这里的$W_{\beta\gamma}^{(\alpha)}$表示从第$\alpha$层到第$\beta$层的第$\gamma$个神经元的权值向量$W$（为了简化，这里省略了转置符号$^T$），$b^{(\alpha)}_\beta$表示从第$\alpha$层到第$\beta$层的偏置$b$。</p><p>这是一个典型的三层神经网络，我们将Layer 2称为隐藏层(Hidden Layer)。一个神经网络中可以拥有多个隐藏层。</p><h3 id="1-2-1-前馈神经网络-Feedforward-neural-network"><a href="#1-2-1-前馈神经网络-Feedforward-neural-network" class="headerlink" title="1.2.1. 前馈神经网络 Feedforward neural network"></a>1.2.1. 前馈神经网络 Feedforward neural network</h3><p>像这样，在神经网络内部，输入从输入层向输出层单向传播，不构成任何有向环的结构，我们称之为前馈神经网络。</p><h3 id="1-2-2-反向传播-Backpropagation"><a href="#1-2-2-反向传播-Backpropagation" class="headerlink" title="1.2.2. 反向传播 Backpropagation"></a>1.2.2. 反向传播 Backpropagation</h3><p>下一个要解决的问题是，怎样合理地确定神经网络中各层的权值。这句需要用到反向传播算法。</p><p>反向传播算法是训练神经网络的常用方法，该方法利用<a href="https://zh.wikipedia.org/wiki/%E9%93%BE%E5%BC%8F%E6%B3%95%E5%88%99" target="_blank" rel="noopener">链式法则</a>对网络中的所有权值计算<strong>损失函数</strong>的梯度，用来<strong>更新权值</strong>以最小化损失函数，本质上是一种<a href="https://zh.wikipedia.org/wiki/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95" target="_blank" rel="noopener">梯度下降法</a>。</p><p><img src="/assets/30522079.jpg" alt=""></p><p>反向传播算法有两个阶段：激励传播和权值更新</p><h4 id="激励传播"><a href="#激励传播" class="headerlink" title="激励传播"></a>激励传播</h4><ol><li>前向传播：输入进入神经网络并前向传播，最后产生输出。</li><li>反向传播：通过损失函数求出输出与标准输出之间的误差，然后通过链式法则求出每一层的权值参数对整体误差的影响（即总误差对权值参数求偏导）。</li></ol><h4 id="权值更新"><a href="#权值更新" class="headerlink" title="权值更新"></a>权值更新</h4><ol><li>将输入带入前面的求到结果中，获得权值梯度。</li><li>将权值乘上<strong>一个负的学习率</strong>，加到现有的权值上，以更新它的值。</li></ol><p>具体实例在<a href="https://www.cnblogs.com/charlotte77/p/5629865.html" target="_blank" rel="noopener">这篇博客</a>中有非常详细的过程。</p><h3 id="1-2-3-问题"><a href="#1-2-3-问题" class="headerlink" title="1.2.3. 问题"></a>1.2.3. 问题</h3><p>在前面我们就曾提到过，在我们现在介绍的神经网络中有一个由于全连接导致的巨大问题————参数数量巨大。</p><p>想象一下，假如输入是1000X1000的灰度图片（一个channel），也就是一个$10^6$个值，第二层隐藏层有$10^6$个神经元，那我们将面临$10^{12}$次方个权值。这样的参数数量是不可接受的。因此我们需要想一个办法去解决这个问题。</p><h1 id="2-卷积神经网络"><a href="#2-卷积神经网络" class="headerlink" title="2. 卷积神经网络"></a>2. 卷积神经网络</h1><h2 id="2-1-局部连接-Locally-Connected"><a href="#2-1-局部连接-Locally-Connected" class="headerlink" title="2.1. 局部连接 Locally Connected"></a>2.1. 局部连接 Locally Connected</h2><p>人对外界的认知是从局部到总体的，我们总是先对图像中的细节————例如边缘、颜色等有了认识，逐渐辨别轮廓，最后识别出物体。另外一个直觉的想法是，图像中的像素点总是和邻近的点关系密切，和距离较远的点关系较小甚至没有关系。</p><p>也就是说，一个单一的神经元没有必要对整个输入图像进行感知（全连接）。神经元只需要对局部进行感知（局部连接），再由更高层的神经元进行综合即可。</p><p><img src="/assets/84598650.jpg" alt=""></p><p>如上图，第二层隐藏层中的神经元只将部分值当做输入，最后由第三层隐藏层进行全连接。</p><p>回到之前的假设，假如输入依旧是1000X1000的灰度图片，第二层隐藏层依旧有$10^6$个神经元。但此时利用局部连接，第二层的神经元每个值对应输入中10X10的图像范围，那么每个神经元只需要100个权值。此时权值总数就是$10^8$个，远小于$10^{12}$个。</p><h2 id="2-2-参数共享-Shared-Weights"><a href="#2-2-参数共享-Shared-Weights" class="headerlink" title="2.2. 参数共享 Shared Weights"></a>2.2. 参数共享 Shared Weights</h2><p>$10^8$个权值参数虽然对比$10^{12}$已经是相当大的进步，但我们仍然可以进一步缩小它，解决的方案就是参数共享。</p><p>第二层的$10^6$个神经元均采用不同的参数，设想一下，加入它们都采用一样的100个权值参数，那么参数的总数就只剩下了100。</p><p>我们可以这样理解权值共享，这100个参数其实是通过卷积提取图片的特征的方式。在没有权值共享之前，每个神经元提取特征的方式都是不同的（因为它们的权值参数不同）。而现在所有神经元共享这100个参数，那所有的神经元就会以相同的方式提取图片特征。又因为上述局部连接的存在，每个神经元提取特征的位置是不一样的。最终导致的结果是，每个神经元在各自的局部，用相同的方式提取特征。</p><p>这100个参数实际上是10X10的矩阵，我们将这个矩阵成为<strong>卷积核(Kernel)</strong>，卷积(Convolution)的过程就是这个卷积核在图片上游走，将覆盖范围内的所有输入值与卷积核对应位置的权值相乘累加。重复这个过程直到提取出<strong>特征图(Feature Map)</strong>，如下图所示。</p><p><img src="/assets/2018-3-29201953.gif" alt=""></p><h3 id="2-2-1-对灰度图像卷积"><a href="#2-2-1-对灰度图像卷积" class="headerlink" title="2.2.1. 对灰度图像卷积"></a>2.2.1. 对灰度图像卷积</h3><p>对于一个图像，每个像素点由RGB三个值描述，也就是说一个图像是一个三维矩阵。我们将这三个维度分别称为长、宽和通道。</p><p>对于一个卷积核，也有三个维度，分别为长、宽和深度。</p><p>一次卷积操作有多个参数需要考虑：</p><ul><li>Size：每个卷积核的大小 Width*Height*Depth。</li><li>Stride：卷积核每次移动的步长。</li><li>Padding：卷积核在遇到边缘时补0的宽度。</li></ul><p>现在我们考虑比较简单的情况，灰度图像的特点是，只有一个通道，那么按照上述要求，卷积核的深度只需要为1就行了。</p><p>下图展示了一个Size为3X3X1的卷积核在Stride为2、Padding为1情况下，对一个5X5X1灰度图像的卷积操作：</p><p><img src="/assets/numerical_padding_strides.gif" alt=""></p><h3 id="2-2-2-对多通道图像卷积"><a href="#2-2-2-对多通道图像卷积" class="headerlink" title="2.2.2. 对多通道图像卷积"></a>2.2.2. 对多通道图像卷积</h3><p>对于多个通道的图像，则要求卷积核的深度必须与输入图像的通道数一致。对于RGB三通道图像，则要求卷积核的深度必须为3。</p><p>下图展示了一个Size为3X3X3的卷积核在Stride为2、Padding为0的情况下，对一个9X9X3的RGB图像的卷积操作：</p><p><img src="/assets/ezgif-3-42672af34c.gif" alt=""></p><h3 id="2-2-3-计算特征图的大小"><a href="#2-2-3-计算特征图的大小" class="headerlink" title="2.2.3. 计算特征图的大小"></a>2.2.3. 计算特征图的大小</h3><p>由于卷积核的深度总是与输入图像的通道数一致，所以输出的特征图总是一个二维矩阵，我们可以通过下面的公式计算出特征图的大小：</p><p>$$W_{new}=\frac{W_{old}+Padding*2-W_{kernel}}{stride}+1$$</p><p>这里W代表Width，同理可以计算出Height。</p><h2 id="2-3-多核卷积"><a href="#2-3-多核卷积" class="headerlink" title="2.3. 多核卷积"></a>2.3. 多核卷积</h2><p>我们知道，一次卷积操作生成的特征图，是利用一个卷积核提取出来的一种特征。为了能够增加特征的数量，我们可以使用多个卷积核Size、Stride、Padding完全相同，但参数不同的卷积核对输入图像进行卷积。</p><p>下图展示了我们使用两个卷积核的卷机操作：</p><p><img src="/assets/ezgif-3-3d5bb5e0dd.gif" alt=""></p><p>可以发现，输出的特征图的通道数，与输入图像的通道数无关，而是与卷积核的数量有关。使用的卷积核的数量越多，我们提取的特征数量就越多，特征图的通道数也越多。</p><h2 id="2-4-多层卷积"><a href="#2-4-多层卷积" class="headerlink" title="2.4. 多层卷积"></a>2.4. 多层卷积</h2><p>图像是以像素点为单位作为输入的，隐藏层对输入卷积，提取出局部特征（比如边缘）。接下来的下一个隐藏层又以之前隐藏层的输出作为输入进行卷积，提取出抽象等级更高的特征（比如轮廓）。最后不断地增加隐藏层的数量，不断提取抽象等级更高的特征。最后进行全连接，使得学习的特征具有全局化的特性。</p><h2 id="2-5-过拟合-Overfitting"><a href="#2-5-过拟合-Overfitting" class="headerlink" title="2.5. 过拟合 Overfitting"></a>2.5. 过拟合 Overfitting</h2><p>一般一个机器学习算法在训练集上训练，最后训练出来的模型被期望在用于预测时也拥有良好的表现，我们称之为泛化性。</p><p>然而如果一个模型开始学习训练集数据中的特化性质或者随即特征，在预测时对于未知数据的表现就会变差，我们称之为过拟合。</p><p>举一个简单的例子是，如果一个神经网络被训练用于分辨出所有的轿车。泛化性良好的情况下，模型只学习了轿车的通用特征，比如拥有四个轮子、车大灯、后备箱等。但如果我们的训练集中所有的轿车都是白色的，模型过度学习认为只有白色的才是轿车，这就是过拟合现象。</p><h3 id="2-5-1-池化-Polling"><a href="#2-5-1-池化-Polling" class="headerlink" title="2.5.1. 池化 Polling"></a>2.5.1. 池化 Polling</h3><p>通过卷积获得特征之后，我们希望使用这些特征去分类。理论上，我们可以使用提取到的所有特征去分类，但这样会面临极其大的数据量。</p><p>例如对于一个96X96X1的输入图像，我们使用一400个8X8的卷积核进行卷积（Stride为1、Padding为0），那么我们最终会得到一个89X89X400的特征图。这个特征图中拥有超过三百万个数据，如此庞大的数据量难以学习，且容易出现过拟合的现象。我们可以选择池化来解决这个问题。</p><p>所谓池化，就是尝试使用一个更小的特征图去描述一个巨大的特征图。就像我们人类观察一个巨大的图片时，我们并不会注意图片中的每个细节，而是在每个区域选出有代表性特征，然后组合这些特征形成一个更小更利于理解的特征图。使用池化可以大大降低特征图的大小，并且减少过拟合现象。</p><p><img src="/assets/800px-Pooling_schematic.gif" alt=""></p><p>上图描述了一个典型的池化操作，将这个特征图分为四个部分，每个部分取出一个代表性特征，并最终形成一个4X4的池化特征图。</p><p>和卷积一样，池化也有几个需要考虑参数：</p><ul><li>Size：每次池化的范围</li><li>Stride：池化范围在特征图移动的距离</li></ul><p>上图就是一个典型的<code>Size=Stride</code>的池化。</p><h4 id="池化方法"><a href="#池化方法" class="headerlink" title="池化方法"></a>池化方法</h4><ul><li>平均池化：Size=Stride，取池化范围中所有的值的均值作为特征</li><li>最大池化：Size=Stride，取池化范围中的最大值作为特征</li><li>重叠池化：Stride&lt;Size，此时池化范围会有重叠，包含重叠平均池化和重叠最大池化。</li></ul><h3 id="2-5-2-失活-Dropout"><a href="#2-5-2-失活-Dropout" class="headerlink" title="2.5.2. 失活 Dropout"></a>2.5.2. 失活 Dropout</h3><p>一个降低预测误差的方法是，我们训练多个不同的模型，并且将这些模型的预测结果结合起来。这是一个很好的想法，但是代价也相当的大。训练一个模型已经需要相当长的时间，训练多个模型的成本将成倍增加，但是收益却并没有那么显著。因此一个折中的方案被提出————失活。</p><p>失活这个机制在神经网络中作用的方式是，对于每次输入，隐藏层中的每个神经元的输出都有一定的概率（例如0.5）被设为0，这些失活的神经元不再参与前向传播和反向传播。因此，每次输入，神经网络都会以一种不同的结构，这强迫神经元学习更加鲁棒的特征，减少相互之间的依赖，以适应随机的失活机制。</p><p>在实践中，失活机制大大减少了过拟合的现象，代价则是使得收敛的时间翻了一倍。</p><h2 id="2-6-局部响应归一化-Local-Response-Normalization"><a href="#2-6-局部响应归一化-Local-Response-Normalization" class="headerlink" title="2.6. 局部响应归一化 Local Response Normalization"></a>2.6. 局部响应归一化 Local Response Normalization</h2><p>局部响应归一化原理是仿造生物学上活跃的神经细胞对相邻神经细胞的抑制现象（侧抑制）。它将神经网络中响应较强的特征到增强，而响应较弱的特征被抑制，从而加快收敛速度。</p><p>其公式如下：</p><p>$$b_{x,y}^i=a_{x,y}^i/\left(k+\alpha\sum_{j=max(0,i-n/2)}^{min(N-1,i+n/2)}(a_{x,y}^j)^2\right)^\beta$$</p><p>其中$a_{x,y}^i$表示在i通道中的，x、y位置上的点的值，k、$\alpha$、$\beta$、n都是自定义的值。</p><p><img src="/assets/37940075.jpg" alt=""></p><p>从上图我们可以得知，实际上是以$a_{x,y}^i$为中心，沿着通道的轴的方向取n个值累加值作为分母，若该点的值越大，则被加强的越多；若越小，则被抑制的越多。</p><h2 id="2-7-SoftMax"><a href="#2-7-SoftMax" class="headerlink" title="2.7. SoftMax"></a>2.7. SoftMax</h2><p>它能将一个含任意实数的K维的向量$z$的“压缩”到另一个K维实向量$\sigma(z)中，使得每一个元素的范围都在(0,1)之间，并且所有元素的和为1。该函数的形式通常按下面的式子给出：</p><p>$$\sigma(z)_j=\frac{e^{z_j}}{\sum_{k=1}^Ke^{z_k}}$$</p><p>假设神经网络最后的全连接输出的向量为1000维，那么将这1000维的向量输入SoftMax函数中，将会输出1000维的概率向量。这个向量中的每一个值描述了这个输入属于1000个分类中每个分类的概率。</p><p><img src="/assets/31364805.jpg" alt=""></p><h1 id="3-参考"><a href="#3-参考" class="headerlink" title="3. 参考"></a>3. 参考</h1><p>图片来自<a href="https://images.google.com" target="_blank" rel="noopener">Google Image</a></p><p><a href="http://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks" target="_blank" rel="noopener">Krizhevsky A, Sutskever I, Hinton G E. ImageNet Classification with Deep Convolutional Neural Networks</a></p><p><a href="https://zh.wikipedia.org/wiki/%E5%89%8D%E9%A6%88%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C" target="_blank" rel="noopener">维基百科. 前馈神经网络</a></p><p><a href="https://zh.wikipedia.org/wiki/%E6%84%9F%E7%9F%A5%E5%99%A8" target="_blank" rel="noopener">维基百科. 感知器</a></p><p><a href="http://deeplearning.stanford.edu/wiki/index.php/UFLDL%E6%95%99%E7%A8%8B" target="_blank" rel="noopener">UFLDL教程</a></p><p><a href="https://zh.wikipedia.org/wiki/%E9%93%BE%E5%BC%8F%E6%B3%95%E5%88%99" target="_blank" rel="noopener">维基百科. 链式法则</a></p><p><a href="https://zh.wikipedia.org/wiki/%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">维基百科. 反向传播算法</a></p><p><a href="https://www.cnblogs.com/charlotte77/p/5629865.html" target="_blank" rel="noopener">Charlotte77. 一文弄懂神经网络中的反向传播法——BackPropagation</a></p><p><a href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E6%95%B4%E6%B5%81%E5%87%BD%E6%95%B0" target="_blank" rel="noopener">维基百科. 线性整流函数</a></p><p><a href="https://zh.wikipedia.org/wiki/%E9%81%8E%E9%81%A9" target="_blank" rel="noopener">维基百科. 过拟合</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近主要通过阅读论文的方式，学习了卷积神经网络的基本概念、结构、方法。这篇周报主要是对所学知识的一些总结。&lt;/p&gt;
&lt;p&gt;如果有错误，烦请在评论区指正。&lt;/p&gt;
    
    </summary>
    
      <category term="Homework" scheme="http://blog.andiedie.cn/categories/Homework/"/>
    
    
  </entry>
  
  <entry>
    <title>树莓派系统安装与配置</title>
    <link href="http://blog.andiedie.cn/posts/159d/"/>
    <id>http://blog.andiedie.cn/posts/159d/</id>
    <published>2017-08-01T03:14:00.000Z</published>
    <updated>2017-12-09T07:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文涉及到树莓派系统安装，SSH登录，镜像加速配置，无线网卡配置，挂载NTFS硬盘。<br><a id="more"></a></p><h1 id="一、写入系统"><a href="#一、写入系统" class="headerlink" title="一、写入系统"></a>一、写入系统</h1><p>由于没有多余的显示屏可以使用，所以只能盲装系统。<br>系统可以从<a href="https://www.raspberrypi.org/downloads/" target="_blank" rel="noopener">这里</a>下载，由于没有显示器，所以我选择了以下版本</p><p><img src="/assets/x758k9ch10xx42ozti9g7v2954ciupdb.png" alt="树莓派系统"></p><p>Windows下烧录系统还需要<a href="win32diskimager">win32diskimager</a><br>插上SD卡，在Win32DiskImager中选择下载的系统镜像和设备，写入。</p><p><img src="/assets/o1m5mfth9kx08bdft3unjgdfms4wt41u.png" alt="写入系统"></p><p>写入成功后，在盘符为<code>boot</code>的U盘根目录下，创建一个<strong>名为<code>ssh</code>的空文件</strong>。这是因为新版本的Raspbian默认不开启ssh，可以通过这个方式让其打开ssh功能。</p><p>将SD卡插入树莓派，连上网线和电源。</p><h1 id="二、SSH登录树莓派"><a href="#二、SSH登录树莓派" class="headerlink" title="二、SSH登录树莓派"></a>二、SSH登录树莓派</h1><p>首先需要获取树莓派在内网的地址，这里通过路由器来查看。</p><p><img src="/assets/ju0rb6kyhzluwdfehvjrbd20lvw4csy8.png" alt="树莓派内网IP"></p><p>使用SSH登录树莓派，账户pi，密码raspberry<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh pi@192.168.0.103</span><br></pre></td></tr></table></figure></p><h1 id="三、配置镜像加速"><a href="#三、配置镜像加速" class="headerlink" title="三、配置镜像加速"></a>三、配置镜像加速</h1><p>国外的apt-get源实在是太慢了，这替换成<a href="https://mirrors.tuna.tsinghua.edu.cn/help/raspbian/" target="_blank" rel="noopener">清华大学Raspbian镜像</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/apt/sources.list</span><br></pre></td></tr></table></figure></p><p>将<code>/etc/apt/sources.list</code>的内容替换为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ jessie main non-free contrib</span><br><span class="line">deb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ jessie main non-free contrib</span><br></pre></td></tr></table></figure></p><p>然后运行<code>sudo apt-get update</code></p><h1 id="四、配置无线网卡"><a href="#四、配置无线网卡" class="headerlink" title="四、配置无线网卡"></a>四、配置无线网卡</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig wlan0</span><br></pre></td></tr></table></figure><p>可以看到树莓派已经成功挂载无线网卡</p><p><img src="/assets/xjn6bifxvnvud50lfbgxkdio42xpgm2h.png" alt="无线网卡"></p><p>修改配置<code>/etc/network/interfaces</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">source-directory /etc/network/interfaces.d</span><br><span class="line"></span><br><span class="line">auto lo wlan0 wlan1</span><br><span class="line"></span><br><span class="line">iface lo inet loopback</span><br><span class="line">iface eth0 inet dhcp</span><br><span class="line"></span><br><span class="line">allow-hotplug wlan0 wlan1</span><br><span class="line"></span><br><span class="line">iface wlan0 inet dhcp</span><br><span class="line">wpa-conf /etc/wpa_supplicant/wpa_supplicant.conf</span><br><span class="line"></span><br><span class="line">iface wlan1 inet manual</span><br></pre></td></tr></table></figure></p><p>修改配置<code>/etc/wpa_supplicant/wpa_supplicant.conf</code><br>注意 <code>priority</code> 高的wifi将被优先连接<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">country=GB</span><br><span class="line">ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev</span><br><span class="line">update_config=1</span><br><span class="line"></span><br><span class="line">network=&#123;</span><br><span class="line">        ssid=&quot;WIFI名1&quot;</span><br><span class="line">        psk=&quot;WIFI密码1&quot;</span><br><span class="line">        priority=2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">network=&#123;</span><br><span class="line">        ssid=&quot;WIFI名2&quot;</span><br><span class="line">        psk=&quot;WIFI密码2&quot;</span><br><span class="line">        priority=1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行命令<code>sudo ifup wlan0</code></p><p><img src="/assets/w2anucw80pbn79v3lyh4klyrox8pyodi.png" alt="链接wifi"></p><p>红色部分则为wifi链接的ip</p><h1 id="五、挂载硬盘"><a href="#五、挂载硬盘" class="headerlink" title="五、挂载硬盘"></a>五、挂载硬盘</h1><p>由于我的移动硬盘是NTFS格式，所以需要下载对应的驱动<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ntfs-3g</span><br></pre></td></tr></table></figure></p><p>将移动硬盘连接到树莓派，使用<code>sudo fdisk -l</code>查看磁盘状况</p><p><img src="/assets/e6gqrzakw4anbttm4kxcti2v9g561a2b.png" alt="硬盘情况"></p><p>在<code>/dev/sda1</code>发现移动硬盘，这里<code>sda1</code>取决于你的情况，<code>a</code>表示第一个硬盘，<code>1</code>表示第一个分区</p><p>创建文件夹并挂载磁盘<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /mnt/usb</span><br><span class="line">sudo mount -o uid=pi,gid=pi /dev/sda1 /mnt/usb</span><br></pre></td></tr></table></figure></p><p>卸载磁盘方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo umount /mnt/usb</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文涉及到树莓派系统安装，SSH登录，镜像加速配置，无线网卡配置，挂载NTFS硬盘。&lt;br&gt;
    
    </summary>
    
      <category term="Tutorial" scheme="http://blog.andiedie.cn/categories/Tutorial/"/>
    
    
  </entry>
  
</feed>
